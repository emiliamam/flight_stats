{"ast":null,"code":"import { createSelector } from 'reselect';\nimport { computeLinePoints } from '../../cartesian/Line';\nimport { selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectAxisWithScale, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { getBandSizeOfAxis, isCategoricalAxis } from '../../util/ChartUtils';\n\nvar selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, 'xAxis', xAxisId, isPanorama);\n\nvar selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', xAxisId, isPanorama);\n\nvar selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, 'yAxis', yAxisId, isPanorama);\n\nvar selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', yAxisId, isPanorama);\n\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\n\nvar pickLineSettings = (_state, _xAxisId, _yAxisId, _isPanorama, lineSettings) => lineSettings;\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\n\n\nvar selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineSettings], (graphicalItems, lineSettingsFromProps) => {\n  if (graphicalItems.some(cgis => cgis.type === 'line' && lineSettingsFromProps.dataKey === cgis.dataKey && lineSettingsFromProps.data === cgis.data)) {\n    /*\n     * now, at least one of the lines has the same dataKey as the one in props.\n     * Is this a perfect match? Maybe not because we could theoretically have two different Lines with the same dataKey\n     * and the same stackId and the same data but still different lines, yes,\n     * but the chances of that happening are ... lowish.\n     *\n     * A proper fix would be to store the lineSettings in a state too, and compare references directly instead of enumerating the properties.\n     */\n    return lineSettingsFromProps;\n  }\n\n  return undefined;\n});\nexport var selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectSynchronisedLineSettings, selectBandSize, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n\n  if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n\n  var {\n    dataKey,\n    data\n  } = lineSettings;\n  var displayedData;\n\n  if (data != null && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n\n  if (displayedData == null) {\n    return undefined;\n  }\n\n  return computeLinePoints({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  });\n});","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/recharts/es6/state/selectors/lineSelectors.js"],"names":["createSelector","computeLinePoints","selectChartDataWithIndexesIfNotInPanorama","selectChartLayout","selectAxisWithScale","selectTicksOfGraphicalItem","selectUnfilteredCartesianItems","getBandSizeOfAxis","isCategoricalAxis","selectXAxisWithScale","state","xAxisId","_yAxisId","isPanorama","selectXAxisTicks","selectYAxisWithScale","_xAxisId","yAxisId","selectYAxisTicks","selectBandSize","layout","xAxis","yAxis","xAxisTicks","yAxisTicks","pickLineSettings","_state","_isPanorama","lineSettings","selectSynchronisedLineSettings","graphicalItems","lineSettingsFromProps","some","cgis","type","dataKey","data","undefined","selectLinePoints","bandSize","_ref","chartData","dataStartIndex","dataEndIndex","length","displayedData","slice"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\nimport { computeLinePoints } from '../../cartesian/Line';\nimport { selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectAxisWithScale, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { getBandSizeOfAxis, isCategoricalAxis } from '../../util/ChartUtils';\nvar selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, 'xAxis', xAxisId, isPanorama);\nvar selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', xAxisId, isPanorama);\nvar selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, 'yAxis', yAxisId, isPanorama);\nvar selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', yAxisId, isPanorama);\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\nvar pickLineSettings = (_state, _xAxisId, _yAxisId, _isPanorama, lineSettings) => lineSettings;\n\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\nvar selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineSettings], (graphicalItems, lineSettingsFromProps) => {\n  if (graphicalItems.some(cgis => cgis.type === 'line' && lineSettingsFromProps.dataKey === cgis.dataKey && lineSettingsFromProps.data === cgis.data)) {\n    /*\n     * now, at least one of the lines has the same dataKey as the one in props.\n     * Is this a perfect match? Maybe not because we could theoretically have two different Lines with the same dataKey\n     * and the same stackId and the same data but still different lines, yes,\n     * but the chances of that happening are ... lowish.\n     *\n     * A proper fix would be to store the lineSettings in a state too, and compare references directly instead of enumerating the properties.\n     */\n    return lineSettingsFromProps;\n  }\n  return undefined;\n});\nexport var selectLinePoints = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectSynchronisedLineSettings, selectBandSize, selectChartDataWithIndexesIfNotInPanorama], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    data\n  } = lineSettings;\n  var displayedData;\n  if (data != null && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n  if (displayedData == null) {\n    return undefined;\n  }\n  return computeLinePoints({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  });\n});"]},"metadata":{},"sourceType":"module"}