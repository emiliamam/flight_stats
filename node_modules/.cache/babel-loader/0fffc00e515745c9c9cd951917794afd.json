{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, {\n  value: 'Module'\n});\n\nconst compareValues = require('../_internal/compareValues.js');\n\nconst isKey = require('../_internal/isKey.js');\n\nconst toPath = require('../util/toPath.js');\n\nfunction orderBy(collection, criteria, orders, guard) {\n  if (collection == null) {\n    return [];\n  }\n\n  orders = guard ? undefined : orders;\n\n  if (!Array.isArray(collection)) {\n    collection = Object.values(collection);\n  }\n\n  if (!Array.isArray(criteria)) {\n    criteria = criteria == null ? [null] : [criteria];\n  }\n\n  if (criteria.length === 0) {\n    criteria = [null];\n  }\n\n  if (!Array.isArray(orders)) {\n    orders = orders == null ? [] : [orders];\n  }\n\n  orders = orders.map(order => String(order));\n\n  const getValueByNestedPath = (object, path) => {\n    let target = object;\n\n    for (let i = 0; i < path.length && target != null; ++i) {\n      target = target[path[i]];\n    }\n\n    return target;\n  };\n\n  const getValueByCriterion = (criterion, object) => {\n    if (object == null || criterion == null) {\n      return object;\n    }\n\n    if (typeof criterion === 'object' && 'key' in criterion) {\n      if (Object.hasOwn(object, criterion.key)) {\n        return object[criterion.key];\n      }\n\n      return getValueByNestedPath(object, criterion.path);\n    }\n\n    if (typeof criterion === 'function') {\n      return criterion(object);\n    }\n\n    if (Array.isArray(criterion)) {\n      return getValueByNestedPath(object, criterion);\n    }\n\n    if (typeof object === 'object') {\n      return object[criterion];\n    }\n\n    return object;\n  };\n\n  const preparedCriteria = criteria.map(criterion => {\n    if (Array.isArray(criterion) && criterion.length === 1) {\n      criterion = criterion[0];\n    }\n\n    if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey.isKey(criterion)) {\n      return criterion;\n    }\n\n    return {\n      key: criterion,\n      path: toPath.toPath(criterion)\n    };\n  });\n  const preparedCollection = collection.map(item => ({\n    original: item,\n    criteria: preparedCriteria.map(criterion => getValueByCriterion(criterion, item))\n  }));\n  return preparedCollection.slice().sort((a, b) => {\n    for (let i = 0; i < preparedCriteria.length; i++) {\n      const comparedResult = compareValues.compareValues(a.criteria[i], b.criteria[i], orders[i]);\n\n      if (comparedResult !== 0) {\n        return comparedResult;\n      }\n    }\n\n    return 0;\n  }).map(item => item.original);\n}\n\nexports.orderBy = orderBy;","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/es-toolkit/dist/compat/array/orderBy.js"],"names":["Object","defineProperty","exports","Symbol","toStringTag","value","compareValues","require","isKey","toPath","orderBy","collection","criteria","orders","guard","undefined","Array","isArray","values","length","map","order","String","getValueByNestedPath","object","path","target","i","getValueByCriterion","criterion","hasOwn","key","preparedCriteria","preparedCollection","item","original","slice","sort","a","b","comparedResult"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst compareValues = require('../_internal/compareValues.js');\nconst isKey = require('../_internal/isKey.js');\nconst toPath = require('../util/toPath.js');\n\nfunction orderBy(collection, criteria, orders, guard) {\n    if (collection == null) {\n        return [];\n    }\n    orders = guard ? undefined : orders;\n    if (!Array.isArray(collection)) {\n        collection = Object.values(collection);\n    }\n    if (!Array.isArray(criteria)) {\n        criteria = criteria == null ? [null] : [criteria];\n    }\n    if (criteria.length === 0) {\n        criteria = [null];\n    }\n    if (!Array.isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n    }\n    orders = orders.map(order => String(order));\n    const getValueByNestedPath = (object, path) => {\n        let target = object;\n        for (let i = 0; i < path.length && target != null; ++i) {\n            target = target[path[i]];\n        }\n        return target;\n    };\n    const getValueByCriterion = (criterion, object) => {\n        if (object == null || criterion == null) {\n            return object;\n        }\n        if (typeof criterion === 'object' && 'key' in criterion) {\n            if (Object.hasOwn(object, criterion.key)) {\n                return object[criterion.key];\n            }\n            return getValueByNestedPath(object, criterion.path);\n        }\n        if (typeof criterion === 'function') {\n            return criterion(object);\n        }\n        if (Array.isArray(criterion)) {\n            return getValueByNestedPath(object, criterion);\n        }\n        if (typeof object === 'object') {\n            return object[criterion];\n        }\n        return object;\n    };\n    const preparedCriteria = criteria.map((criterion) => {\n        if (Array.isArray(criterion) && criterion.length === 1) {\n            criterion = criterion[0];\n        }\n        if (criterion == null || typeof criterion === 'function' || Array.isArray(criterion) || isKey.isKey(criterion)) {\n            return criterion;\n        }\n        return { key: criterion, path: toPath.toPath(criterion) };\n    });\n    const preparedCollection = collection.map(item => ({\n        original: item,\n        criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item)),\n    }));\n    return preparedCollection\n        .slice()\n        .sort((a, b) => {\n        for (let i = 0; i < preparedCriteria.length; i++) {\n            const comparedResult = compareValues.compareValues(a.criteria[i], b.criteria[i], orders[i]);\n            if (comparedResult !== 0) {\n                return comparedResult;\n            }\n        }\n        return 0;\n    })\n        .map(item => item.original);\n}\n\nexports.orderBy = orderBy;\n"]},"metadata":{},"sourceType":"script"}