{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { inRangeOfSector, polarToCartesian } from './PolarUtils';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n}\nexport var calculateActiveTickIndex = (coordinate, ticks, unsortedTicks, axisType, range) => {\n  var _ticks$length;\n\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0; // if there are 1 or fewer ticks or if there is no coordinate then the active tick is at index 0\n\n  if (len <= 1 || coordinate == null) {\n    return 0;\n  }\n\n  if (axisType === 'angleAxis' && range != null && Math.abs(Math.abs(range[1] - range[0]) - 360) <= 1e-6) {\n    // ticks are distributed in a circle\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          ({\n            index\n          } = unsortedTicks[i]);\n          break;\n        }\n      } else {\n        var minValue = Math.min(before, after);\n        var maxValue = Math.max(before, after);\n\n        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n          ({\n            index\n          } = unsortedTicks[i]);\n          break;\n        }\n      }\n    }\n  } else if (ticks) {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        ({\n          index\n        } = ticks[_i]);\n        break;\n      }\n    }\n  }\n\n  return index;\n};\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\n\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(minValue);\n  }\n\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n\n  return values;\n};\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n\n  if (!scale) {\n    return null;\n  }\n\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  } // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\n\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n\n  return result;\n};\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetSign = series => {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n\n    }\n  }\n};\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\n\nexport var offsetPositive = series => {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n\n    }\n  }\n};\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack().keys(dataKeys).value((d, key) => +getValueByDataKey(d, key, 0)).order(stackOrderNone) // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey); // @ts-expect-error getValueByDataKey does not validate the output type\n\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]); // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n\n    var maxValue = Math.max(domain[0], domain[1]);\n\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n\n    if (maxValue < 0) {\n      return maxValue;\n    }\n\n    return minValue;\n  }\n\n  return domain[0];\n};\n\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\n\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\n\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n\n  return undefined;\n}\nexport function inRange(x, y, layout, polarViewBox, offset) {\n  if (layout === 'horizontal' || layout === 'vertical') {\n    var isInRange = x >= offset.left && x <= offset.left + offset.width && y >= offset.top && y <= offset.top + offset.height;\n    return isInRange ? {\n      x,\n      y\n    } : null;\n  }\n\n  if (polarViewBox) {\n    return inRangeOfSector({\n      x,\n      y\n    }, polarViewBox);\n  }\n\n  return null;\n}\nexport var getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {\n  var entry = tooltipTicks.find(tick => tick && tick.index === activeIndex);\n\n  if (entry) {\n    if (layout === 'horizontal') {\n      return {\n        x: entry.coordinate,\n        y: rangeObj.y\n      };\n    }\n\n    if (layout === 'vertical') {\n      return {\n        x: rangeObj.x,\n        y: entry.coordinate\n      };\n    }\n\n    if (layout === 'centric') {\n      var _angle = entry.coordinate;\n      var {\n        radius: _radius\n      } = rangeObj;\n      return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {\n        angle: _angle,\n        radius: _radius\n      });\n    }\n\n    var radius = entry.coordinate;\n    var {\n      angle\n    } = rangeObj;\n    return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {\n      angle,\n      radius\n    });\n  }\n\n  return {\n    x: 0,\n    y: 0\n  };\n};\nexport var calculateTooltipPos = (rangeObj, layout) => {\n  if (layout === 'horizontal') {\n    return rangeObj.x;\n  }\n\n  if (layout === 'vertical') {\n    return rangeObj.y;\n  }\n\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n\n  return rangeObj.radius;\n};","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/recharts/es6/util/ChartUtils.js"],"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","sortBy","get","stack","shapeStack","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","stackOrderNone","findEntryInArray","isNan","isNullish","isNumber","isNumOrStr","mathSign","inRangeOfSector","polarToCartesian","getValueByDataKey","obj","dataKey","defaultValue","calculateActiveTickIndex","coordinate","ticks","unsortedTicks","axisType","range","_ticks$length","index","len","Math","abs","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","minValue","maxValue","_i","appendOffsetOfLegend","offset","legendSettings","legendSize","width","boxWidth","height","boxHeight","align","verticalAlign","layout","isCategoricalAxis","getCoordinatesOfGrid","syncWithTicks","map","entry","hasMin","hasMax","values","getTicksOfAxis","axis","isGrid","isAll","duplicateDomain","type","scale","realScaleType","isCategorical","categoricalDomain","tickCount","niceTicks","offsetForBand","bandwidth","result","scaleContent","indexOf","row","domain","EPS","checkDomainOfScale","first","last","truncateByDomain","offsetSign","series","n","j","m","positive","negative","offsetPositive","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","data","dataKeys","offsetType","offsetAccessor","d","key","order","getNormalizedStackId","publicStackId","undefined","getCateCoordinateOfLine","_ref","bandSize","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref2","getBaseValueOfBar","_ref3","numericAxis","getDomainOfSingle","flat","makeDomainFinite","Infinity","getDomainOfStackGroups","stackGroups","startIndex","endIndex","reduce","stackId","group","stackedData","res","s","slice","MIN_VALUE_REG","MAX_VALUE_REG","getBandSizeOfAxis","isBar","bandWidth","orderedTicks","prev","getTooltipEntry","_ref4","tooltipEntrySettings","payload","name","getTooltipNameProp","nameFromItem","inRange","x","y","polarViewBox","isInRange","left","top","getActiveCoordinate","tooltipTicks","activeIndex","rangeObj","find","tick","_angle","radius","_radius","cx","cy","angle","calculateTooltipPos"],"mappings":"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","sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport sortBy from 'es-toolkit/compat/sortBy';\nimport get from 'es-toolkit/compat/get';\nimport { stack as shapeStack, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle, stackOrderNone } from 'victory-vendor/d3-shape';\nimport { findEntryInArray, isNan, isNullish, isNumber, isNumOrStr, mathSign } from './DataUtils';\nimport { inRangeOfSector, polarToCartesian } from './PolarUtils';\nexport function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (isNullish(obj) || isNullish(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return get(obj, dataKey, defaultValue);\n  }\n  if (typeof dataKey === 'function') {\n    return dataKey(obj);\n  }\n  return defaultValue;\n}\nexport var calculateActiveTickIndex = (coordinate, ticks, unsortedTicks, axisType, range) => {\n  var _ticks$length;\n  var index = -1;\n  var len = (_ticks$length = ticks === null || ticks === void 0 ? void 0 : ticks.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;\n\n  // if there are 1 or fewer ticks or if there is no coordinate then the active tick is at index 0\n  if (len <= 1 || coordinate == null) {\n    return 0;\n  }\n  if (axisType === 'angleAxis' && range != null && Math.abs(Math.abs(range[1] - range[0]) - 360) <= 1e-6) {\n    // ticks are distributed in a circle\n    for (var i = 0; i < len; i++) {\n      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n      var cur = unsortedTicks[i].coordinate;\n      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n      var sameDirectionCoord = void 0;\n      if (mathSign(cur - before) !== mathSign(after - cur)) {\n        var diffInterval = [];\n        if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n          sameDirectionCoord = after;\n          var curInRange = cur + range[1] - range[0];\n          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n        } else {\n          sameDirectionCoord = before;\n          var afterInRange = after + range[1] - range[0];\n          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n        }\n        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n          ({\n            index\n          } = unsortedTicks[i]);\n          break;\n        }\n      } else {\n        var minValue = Math.min(before, after);\n        var maxValue = Math.max(before, after);\n        if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {\n          ({\n            index\n          } = unsortedTicks[i]);\n          break;\n        }\n      }\n    }\n  } else if (ticks) {\n    // ticks are distributed in a single direction\n    for (var _i = 0; _i < len; _i++) {\n      if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n        ({\n          index\n        } = ticks[_i]);\n        break;\n      }\n    }\n  }\n  return index;\n};\nexport var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {\n  if (legendSettings && legendSize) {\n    var {\n      width: boxWidth,\n      height: boxHeight\n    } = legendSize;\n    var {\n      align,\n      verticalAlign,\n      layout\n    } = legendSettings;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'middle') && align !== 'center' && isNumber(offset[align])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [align]: offset[align] + (boxWidth || 0)\n      });\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && verticalAlign !== 'middle' && isNumber(offset[verticalAlign])) {\n      return _objectSpread(_objectSpread({}, offset), {}, {\n        [verticalAlign]: offset[verticalAlign] + (boxHeight || 0)\n      });\n    }\n  }\n  return offset;\n};\nexport var isCategoricalAxis = (layout, axisType) => layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks           The ticks in axis\n * @param {Number} minValue        The minimum value of axis\n * @param {Number} maxValue        The maximum value of axis\n * @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not\n * @return {Array}                 Coordinates\n */\nexport var getCoordinatesOfGrid = (ticks, minValue, maxValue, syncWithTicks) => {\n  if (syncWithTicks) {\n    return ticks.map(entry => entry.coordinate);\n  }\n  var hasMin, hasMax;\n  var values = ticks.map(entry => {\n    if (entry.coordinate === minValue) {\n      hasMin = true;\n    }\n    if (entry.coordinate === maxValue) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(minValue);\n  }\n  if (!hasMax) {\n    values.push(maxValue);\n  }\n  return values;\n};\n\n/**\n * A subset of d3-scale that Recharts is using\n */\n\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\nexport var getTicksOfAxis = (axis, isGrid, isAll) => {\n  if (!axis) {\n    return null;\n  }\n  var {\n    duplicateDomain,\n    type,\n    range,\n    scale,\n    realScaleType,\n    isCategorical,\n    categoricalDomain,\n    tickCount,\n    ticks,\n    niceTicks,\n    axisType\n  } = axis;\n  if (!scale) {\n    return null;\n  }\n  var offsetForBand = realScaleType === 'scaleBand' && scale.bandwidth ? scale.bandwidth() / 2 : 2;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && range && range.length >= 2 ? mathSign(range[0] - range[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  if (isGrid && (ticks || niceTicks)) {\n    var result = (ticks || niceTicks || []).map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset,\n        index\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks && !isAll && tickCount != null) {\n    return scale.ticks(tickCount).map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset,\n      index\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = scale => {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var minValue = Math.min(range[0], range[1]) - EPS;\n  var maxValue = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < minValue || first > maxValue || last < minValue || last > maxValue) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\n\n/**\n * Both value and domain are tuples of two numbers\n * - but the type stays as array of numbers until we have better support in rest of the app\n * @param value input that will be truncated\n * @param domain boundaries\n * @returns tuple of two numbers\n */\nexport var truncateByDomain = (value, domain) => {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var minValue = Math.min(domain[0], domain[1]);\n  var maxValue = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < minValue) {\n    result[0] = minValue;\n  }\n  if (!isNumber(value[1]) || value[1] > maxValue) {\n    result[1] = maxValue;\n  }\n  if (result[0] > maxValue) {\n    result[0] = maxValue;\n  }\n  if (result[1] < minValue) {\n    result[1] = minValue;\n  }\n  return result;\n};\n\n/**\n * Stacks all positive numbers above zero and all negative numbers below zero.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetSign = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Replaces all negative values with zero when stacking data.\n *\n * If all values in the series are positive then this behaves the same as 'none' stacker.\n *\n * @param {Array} series from d3-shape Stack\n * @return {Array} series with applied offset\n */\nexport var offsetPositive = series => {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n\n      /* eslint-disable prefer-destructuring, no-param-reassign */\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = 0;\n        series[i][j][1] = 0;\n      }\n      /* eslint-enable prefer-destructuring, no-param-reassign */\n    }\n  }\n};\n\n/**\n * Function type to compute offset for stacked data.\n *\n * d3-shape has something fishy going on with its types.\n * In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.\n * However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.\n * The same I can see in the source code itself:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n * That one unfortunately has no types but we can tell it passes three-dimensional array.\n *\n * Which leads me to believe that definitelytyped is wrong on this one.\n * There's open discussion on this topic without much attention:\n * https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042\n */\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  // @ts-expect-error definitelytyped types are incorrect\n  expand: stackOffsetExpand,\n  // @ts-expect-error definitelytyped types are incorrect\n  none: stackOffsetNone,\n  // @ts-expect-error definitelytyped types are incorrect\n  silhouette: stackOffsetSilhouette,\n  // @ts-expect-error definitelytyped types are incorrect\n  wiggle: stackOffsetWiggle,\n  positive: offsetPositive\n};\nexport var getStackedData = (data, dataKeys, offsetType) => {\n  var offsetAccessor = STACK_OFFSET_MAP[offsetType];\n  var stack = shapeStack().keys(dataKeys).value((d, key) => +getValueByDataKey(d, key, 0)).order(stackOrderNone)\n  // @ts-expect-error definitelytyped types are incorrect\n  .offset(offsetAccessor);\n  return stack(data);\n};\n\n/**\n * Stack IDs in the external props allow numbers; but internally we use it as an object key\n * and object keys are always strings. Also it would be kinda confusing if stackId=8 and stackId='8' were different stacks\n * so let's just force a string.\n */\n\nexport function getNormalizedStackId(publicStackId) {\n  return publicStackId == null ? undefined : String(publicStackId);\n}\nexport function getCateCoordinateOfLine(_ref) {\n  var {\n    axis,\n    ticks,\n    bandSize,\n    entry,\n    index,\n    dataKey\n  } = _ref;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {\n      // @ts-expect-error why does this use direct object access instead of getValueByDataKey?\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);\n\n  // @ts-expect-error getValueByDataKey does not validate the output type\n  return !isNullish(value) ? axis.scale(value) : null;\n}\nexport var getCateCoordinateOfBar = _ref2 => {\n  var {\n    axis,\n    ticks,\n    offset,\n    bandSize,\n    entry,\n    index\n  } = _ref2;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);\n  return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = _ref3 => {\n  var {\n    numericAxis\n  } = _ref3;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var minValue = Math.min(domain[0], domain[1]);\n    // @ts-expect-error type number means the domain has numbers in it but this relationship is not known to typescript\n    var maxValue = Math.max(domain[0], domain[1]);\n    if (minValue <= 0 && maxValue >= 0) {\n      return 0;\n    }\n    if (maxValue < 0) {\n      return maxValue;\n    }\n    return minValue;\n  }\n  return domain[0];\n};\nvar getDomainOfSingle = data => {\n  var flat = data.flat(2).filter(isNumber);\n  return [Math.min(...flat), Math.max(...flat)];\n};\nvar makeDomainFinite = domain => {\n  return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];\n};\nexport var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {\n  if (stackGroups == null) {\n    return undefined;\n  }\n  return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {\n    var group = stackGroups[stackId];\n    var {\n      stackedData\n    } = group;\n    var domain = stackedData.reduce((res, entry) => {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]));\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\n\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @param  {Boolean} isBar if items in axis are bars\n * @return {Number} Size\n */\nexport var getBandSizeOfAxis = (axis, ticks, isBar) => {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    var bandWidth = axis.scale.bandwidth();\n    if (!isBar || bandWidth > 0) {\n      return bandWidth;\n    }\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = sortBy(ticks, o => o.coordinate);\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return isBar ? undefined : 0;\n};\nexport function getTooltipEntry(_ref4) {\n  var {\n    tooltipEntrySettings,\n    dataKey,\n    payload,\n    value,\n    name\n  } = _ref4;\n  return _objectSpread(_objectSpread({}, tooltipEntrySettings), {}, {\n    dataKey,\n    payload,\n    value,\n    name\n  });\n}\nexport function getTooltipNameProp(nameFromItem, dataKey) {\n  if (nameFromItem) {\n    return String(nameFromItem);\n  }\n  if (typeof dataKey === 'string') {\n    return dataKey;\n  }\n  return undefined;\n}\nexport function inRange(x, y, layout, polarViewBox, offset) {\n  if (layout === 'horizontal' || layout === 'vertical') {\n    var isInRange = x >= offset.left && x <= offset.left + offset.width && y >= offset.top && y <= offset.top + offset.height;\n    return isInRange ? {\n      x,\n      y\n    } : null;\n  }\n  if (polarViewBox) {\n    return inRangeOfSector({\n      x,\n      y\n    }, polarViewBox);\n  }\n  return null;\n}\nexport var getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {\n  var entry = tooltipTicks.find(tick => tick && tick.index === activeIndex);\n  if (entry) {\n    if (layout === 'horizontal') {\n      return {\n        x: entry.coordinate,\n        y: rangeObj.y\n      };\n    }\n    if (layout === 'vertical') {\n      return {\n        x: rangeObj.x,\n        y: entry.coordinate\n      };\n    }\n    if (layout === 'centric') {\n      var _angle = entry.coordinate;\n      var {\n        radius: _radius\n      } = rangeObj;\n      return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {\n        angle: _angle,\n        radius: _radius\n      });\n    }\n    var radius = entry.coordinate;\n    var {\n      angle\n    } = rangeObj;\n    return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {\n      angle,\n      radius\n    });\n  }\n  return {\n    x: 0,\n    y: 0\n  };\n};\nexport var calculateTooltipPos = (rangeObj, layout) => {\n  if (layout === 'horizontal') {\n    return rangeObj.x;\n  }\n  if (layout === 'vertical') {\n    return rangeObj.y;\n  }\n  if (layout === 'centric') {\n    return rangeObj.angle;\n  }\n  return rangeObj.radius;\n};"]},"metadata":{},"sourceType":"module"}