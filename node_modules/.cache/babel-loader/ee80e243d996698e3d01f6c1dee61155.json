{"ast":null,"code":"var _excluded = [\"type\", \"layout\", \"connectNulls\", \"needClip\"],\n    _excluded2 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\"];\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n\n  var o,\n      r,\n      i = _objectWithoutPropertiesLoose(e, t);\n\n  if (Object.getOwnPropertySymbols) {\n    var n = Object.getOwnPropertySymbols(e);\n\n    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n\n  return i;\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n\n  return t;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n\n    return n;\n  }, _extends.apply(null, arguments);\n} // eslint-disable-next-line max-classes-per-file\n\n\nimport * as React from 'react';\nimport { Component, PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Dot } from '../shape/Dot';\nimport { Layer } from '../container/Layer';\nimport { LabelList } from '../component/LabelList';\nimport { SetErrorBarPreferredDirection } from './ErrorBar';\nimport { interpolateNumber, isNullish, uniqueId } from '../util/DataUtils';\nimport { filterProps, isClipDot } from '../util/ReactUtils';\nimport { Global } from '../util/Global';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { CartesianGraphicalItemContext, SetErrorBarContext } from '../context/CartesianGraphicalItemContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { useChartLayout } from '../context/chartLayoutContext';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { Animate } from '../animation/Animate';\nimport { usePlotArea } from '../hooks';\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: stroke,\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\n\nfunction getTooltipEntrySettings(props) {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit\n  } = props;\n  return {\n    dataDefinedOnItem: data,\n    positions: undefined,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: props.tooltipType,\n      color: props.stroke,\n      unit\n    }\n  };\n}\n\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n};\n\nfunction repeat(lines, count) {\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\n  var result = [];\n\n  for (var i = 0; i < count; ++i) {\n    result = [...result, ...linesUnit];\n  }\n\n  return result;\n}\n\nvar getStrokeDasharray = (length, totalLength, lines) => {\n  var lineLength = lines.reduce((pre, next) => pre + next); // if lineLength is 0 return the default when no strokeDasharray is provided\n\n  if (!lineLength) {\n    return generateSimpleStrokeDasharray(totalLength, length);\n  }\n\n  var count = Math.floor(length / lineLength);\n  var remainLength = length % lineLength;\n  var restLength = totalLength - length;\n  var remainLines = [];\n\n  for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {\n    if (sum + lines[i] > remainLength) {\n      remainLines = [...lines.slice(0, i), remainLength - sum];\n      break;\n    }\n  }\n\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\n};\n\nfunction renderDotItem(option, props) {\n  var dotItem;\n\n  if ( /*#__PURE__*/React.isValidElement(option)) {\n    dotItem = /*#__PURE__*/React.cloneElement(option, props);\n  } else if (typeof option === 'function') {\n    dotItem = option(props);\n  } else {\n    var className = clsx('recharts-line-dot', typeof option !== 'boolean' ? option.className : '');\n    dotItem = /*#__PURE__*/React.createElement(Dot, _extends({}, props, {\n      className: className\n    }));\n  }\n\n  return dotItem;\n}\n\nfunction shouldRenderDots(points, dot) {\n  if (points == null) {\n    return false;\n  }\n\n  if (dot) {\n    return true;\n  }\n\n  return points.length === 1;\n}\n\nfunction Dots(_ref) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref;\n  var {\n    dot,\n    dataKey,\n    needClip\n  } = props;\n\n  if (!shouldRenderDots(points, dot)) {\n    return null;\n  }\n\n  var clipDot = isClipDot(dot);\n  var lineProps = filterProps(props, false);\n  var customDotProps = filterProps(dot, true);\n  var dots = points.map((entry, i) => {\n    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n      key: \"dot-\".concat(i),\n      r: 3\n    }, lineProps), customDotProps), {}, {\n      index: i,\n      cx: entry.x,\n      cy: entry.y,\n      dataKey,\n      value: entry.value,\n      payload: entry.payload,\n      points\n    });\n\n    return renderDotItem(dot, dotProps);\n  });\n  var dotsProps = {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : null\n  };\n  return /*#__PURE__*/React.createElement(Layer, _extends({\n    className: \"recharts-line-dots\",\n    key: \"dots\"\n  }, dotsProps), dots);\n}\n\nfunction StaticCurve(_ref2) {\n  var {\n    clipPathId,\n    pathRef,\n    points,\n    strokeDasharray,\n    props,\n    showLabels\n  } = _ref2;\n\n  var {\n    type,\n    layout,\n    connectNulls,\n    needClip\n  } = props,\n      others = _objectWithoutProperties(props, _excluded);\n\n  var curveProps = _objectSpread(_objectSpread({}, filterProps(others, true)), {}, {\n    fill: 'none',\n    className: 'recharts-line-curve',\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null,\n    points,\n    type,\n    layout,\n    connectNulls,\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\n  });\n\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Curve, _extends({}, curveProps, {\n    pathRef: pathRef\n  })), /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    clipPathId: clipPathId,\n    props: props\n  }), showLabels && LabelList.renderCallByParent(props, points));\n}\n\nfunction getTotalLength(mainCurve) {\n  try {\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\n  } catch (_unused) {\n    return 0;\n  }\n}\n\nfunction CurveWithAnimation(_ref3) {\n  var {\n    clipPathId,\n    props,\n    pathRef,\n    previousPointsRef,\n    longestAnimatedLengthRef\n  } = _ref3;\n  var {\n    points,\n    strokeDasharray,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    animateNewValues,\n    width,\n    height,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var prevPoints = previousPointsRef.current;\n  var animationId = useAnimationId(props, 'recharts-line-');\n  var [isAnimating, setIsAnimating] = useState(false);\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var totalLength = getTotalLength(pathRef.current);\n  /*\n   * Here we want to detect if the length animation has been interrupted.\n   * For that we keep a reference to the furthest length that has been animated.\n   *\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\n   *\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\n   *\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\n   * and makes it stand out. But it's good enough I suppose.\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\n   *\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\n   * change the dataKey and the Line will continue growing from where it has grown so far.\n   */\n\n  var startingPoint = longestAnimatedLengthRef.current;\n  return /*#__PURE__*/React.createElement(Animate, {\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    from: {\n      t: 0\n    },\n    to: {\n      t: 1\n    },\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, _ref4 => {\n    var {\n      t\n    } = _ref4;\n    var interpolator = interpolateNumber(startingPoint, totalLength + startingPoint);\n    var curLength = Math.min(interpolator(t), totalLength);\n    var currentStrokeDasharray;\n\n    if (strokeDasharray) {\n      var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\n      currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\n    } else {\n      currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\n    }\n\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepData = t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          var interpolatorX = interpolateNumber(prev.x, entry.x);\n          var interpolatorY = interpolateNumber(prev.y, entry.y);\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolatorX(t),\n            y: interpolatorY(t)\n          });\n        } // magic number of faking previous x and y location\n\n\n        if (animateNewValues) {\n          var _interpolatorX = interpolateNumber(width * 2, entry.x);\n\n          var _interpolatorY = interpolateNumber(height / 2, entry.y);\n\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: _interpolatorX(t),\n            y: _interpolatorY(t)\n          });\n        }\n\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          x: entry.x,\n          y: entry.y\n        });\n      }); // eslint-disable-next-line no-param-reassign\n\n      previousPointsRef.current = stepData;\n      return /*#__PURE__*/React.createElement(StaticCurve, {\n        props: props,\n        points: stepData,\n        clipPathId: clipPathId,\n        pathRef: pathRef,\n        showLabels: !isAnimating,\n        strokeDasharray: currentStrokeDasharray\n      });\n    }\n    /*\n     * Here it is important to wait a little bit with updating the previousPointsRef\n     * before the animation has a time to initialize.\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\n     * and before pathRef is set.\n     * If that happens, the Line will re-render again after Legend had reported its height\n     * which will start a new animation with the previous points as the starting point\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\n     *\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\n     * before the pathRef is set, otherwise we will have a wrong total length.\n     */\n\n\n    if (t > 0 && totalLength > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      /*\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\n       * however the same happens when the data change.\n       *\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\n       *\n       * Therefore the totalLength > 0 check.\n       *\n       * The Animate is about to fire handleAnimationStart which will update the state\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\n       * and update the longestAnimatedLengthRef.\n       */\n      // eslint-disable-next-line no-param-reassign\n\n      longestAnimatedLengthRef.current = curLength;\n    }\n\n    return /*#__PURE__*/React.createElement(StaticCurve, {\n      props: props,\n      points: points,\n      clipPathId: clipPathId,\n      pathRef: pathRef,\n      showLabels: !isAnimating,\n      strokeDasharray: currentStrokeDasharray\n    });\n  });\n}\n\nfunction RenderCurve(_ref5) {\n  var {\n    clipPathId,\n    props\n  } = _ref5;\n  var {\n    points,\n    isAnimationActive\n  } = props;\n  var previousPointsRef = useRef(null);\n  var longestAnimatedLengthRef = useRef(0);\n  var pathRef = useRef(null);\n  var prevPoints = previousPointsRef.current;\n\n  if (isAnimationActive && points && points.length && prevPoints !== points) {\n    return /*#__PURE__*/React.createElement(CurveWithAnimation, {\n      props: props,\n      clipPathId: clipPathId,\n      previousPointsRef: previousPointsRef,\n      longestAnimatedLengthRef: longestAnimatedLengthRef,\n      pathRef: pathRef\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(StaticCurve, {\n    props: props,\n    points: points,\n    clipPathId: clipPathId,\n    pathRef: pathRef,\n    showLabels: true\n  });\n}\n\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\n  return {\n    x: dataPoint.x,\n    y: dataPoint.y,\n    value: dataPoint.value,\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n  };\n};\n\nclass LineWithState extends Component {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"id\", uniqueId('recharts-line-'));\n  }\n\n  render() {\n    var _filterProps;\n\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      xAxisId,\n      yAxisId,\n      top,\n      left,\n      width,\n      height,\n      id,\n      needClip,\n      layout\n    } = this.props;\n\n    if (hide) {\n      return null;\n    }\n\n    var layerClass = clsx('recharts-line', className);\n    var clipPathId = isNullish(id) ? this.id : id;\n    var {\n      r = 3,\n      strokeWidth = 2\n    } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n      r: 3,\n      strokeWidth: 2\n    };\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderCurve, {\n      props: this.props,\n      clipPathId: clipPathId\n    }), /*#__PURE__*/React.createElement(SetErrorBarPreferredDirection, {\n      direction: layout === 'horizontal' ? 'y' : 'x'\n    }, /*#__PURE__*/React.createElement(SetErrorBarContext, {\n      xAxisId: xAxisId,\n      yAxisId: yAxisId,\n      data: points,\n      dataPointFormatter: errorBarDataPointFormatter,\n      errorBarOffset: 0\n    }, this.props.children))), /*#__PURE__*/React.createElement(ActivePoints, {\n      activeDot: this.props.activeDot,\n      points: points,\n      mainColor: this.props.stroke,\n      itemDataKey: this.props.dataKey\n    }));\n  }\n\n}\n\nvar defaultLineProps = {\n  activeDot: true,\n  animateNewValues: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: true,\n  fill: '#fff',\n  hide: false,\n  isAnimationActive: !Global.isSsr,\n  label: false,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  xAxisId: 0,\n  yAxisId: 0\n};\n\nfunction LineImpl(props) {\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\n      {\n    activeDot,\n    animateNewValues,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    connectNulls,\n    dot,\n    hide,\n    isAnimationActive,\n    label,\n    legendType,\n    xAxisId,\n    yAxisId\n  } = _resolveDefaultProps,\n      everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = usePlotArea();\n  var layout = useChartLayout();\n  var isPanorama = useIsPanorama();\n  var lineSettings = useMemo(() => ({\n    dataKey: props.dataKey,\n    data: props.data\n  }), [props.dataKey, props.data]);\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, lineSettings));\n\n  if (layout !== 'horizontal' && layout !== 'vertical') {\n    // Cannot render Line in an unsupported layout\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\n    connectNulls: connectNulls,\n    dot: dot,\n    activeDot: activeDot,\n    animateNewValues: animateNewValues,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    isAnimationActive: isAnimationActive,\n    hide: hide,\n    label: label,\n    legendType: legendType,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId,\n    points: points,\n    layout: layout,\n    height: height,\n    width: width,\n    left: left,\n    top: top,\n    needClip: needClip\n  }));\n}\n\nexport function computeLinePoints(_ref6) {\n  var {\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  } = _ref6;\n  return displayedData.map((entry, index) => {\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    var value = getValueByDataKey(entry, dataKey);\n\n    if (layout === 'horizontal') {\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isNullish(value) ? null : yAxis.scale(value),\n        value,\n        payload: entry\n      };\n    }\n\n    return {\n      x: isNullish(value) ? null : xAxis.scale(value),\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value,\n      payload: entry\n    };\n  });\n}\nexport class Line extends PureComponent {\n  render() {\n    // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n    return /*#__PURE__*/React.createElement(CartesianGraphicalItemContext, {\n      type: \"line\",\n      data: this.props.data,\n      xAxisId: this.props.xAxisId,\n      yAxisId: this.props.yAxisId,\n      zAxisId: 0,\n      dataKey: this.props.dataKey // line doesn't stack\n      ,\n      stackId: undefined,\n      hide: this.props.hide,\n      barSize: undefined\n    }, /*#__PURE__*/React.createElement(SetLegendPayload, {\n      legendPayload: computeLegendPayloadFromAreaData(this.props)\n    }), /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n      fn: getTooltipEntrySettings,\n      args: this.props\n    }), /*#__PURE__*/React.createElement(LineImpl, this.props));\n  }\n\n}\n\n_defineProperty(Line, \"displayName\", 'Line');\n\n_defineProperty(Line, \"defaultProps\", defaultLineProps);","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/recharts/es6/cartesian/Line.js"],"names":["_excluded","_excluded2","_objectWithoutProperties","e","t","o","r","i","_objectWithoutPropertiesLoose","Object","getOwnPropertySymbols","n","length","indexOf","propertyIsEnumerable","call","hasOwnProperty","ownKeys","keys","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","_toPrimitive","Symbol","toPrimitive","TypeError","String","Number","_extends","assign","bind","React","Component","PureComponent","useCallback","useMemo","useRef","useState","clsx","Curve","Dot","Layer","LabelList","SetErrorBarPreferredDirection","interpolateNumber","isNullish","uniqueId","filterProps","isClipDot","Global","getCateCoordinateOfLine","getTooltipNameProp","getValueByDataKey","ActivePoints","SetTooltipEntrySettings","CartesianGraphicalItemContext","SetErrorBarContext","GraphicalItemClipPath","useNeedsClip","useChartLayout","useIsPanorama","selectLinePoints","useAppSelector","SetLegendPayload","useAnimationId","resolveDefaultProps","Animate","usePlotArea","computeLegendPayloadFromAreaData","props","dataKey","name","stroke","legendType","hide","inactive","type","color","payload","getTooltipEntrySettings","data","strokeWidth","fill","unit","dataDefinedOnItem","positions","undefined","settings","nameKey","tooltipType","generateSimpleStrokeDasharray","totalLength","concat","repeat","lines","count","linesUnit","result","getStrokeDasharray","lineLength","reduce","pre","next","Math","floor","remainLength","restLength","remainLines","sum","slice","emptyLines","map","line","join","renderDotItem","option","dotItem","isValidElement","cloneElement","className","createElement","shouldRenderDots","points","dot","Dots","_ref","clipPathId","needClip","clipDot","lineProps","customDotProps","dots","entry","dotProps","key","index","cx","x","cy","y","dotsProps","clipPath","StaticCurve","_ref2","pathRef","strokeDasharray","showLabels","layout","connectNulls","others","curveProps","Fragment","renderCallByParent","getTotalLength","mainCurve","_unused","CurveWithAnimation","_ref3","previousPointsRef","longestAnimatedLengthRef","isAnimationActive","animationBegin","animationDuration","animationEasing","animateNewValues","width","height","onAnimationEnd","onAnimationStart","prevPoints","current","animationId","isAnimating","setIsAnimating","handleAnimationEnd","handleAnimationStart","startingPoint","begin","duration","isActive","easing","from","to","_ref4","interpolator","curLength","min","currentStrokeDasharray","split","num","parseFloat","prevPointsDiffFactor","stepData","prevPointIndex","prev","interpolatorX","interpolatorY","_interpolatorX","_interpolatorY","RenderCurve","_ref5","errorBarDataPointFormatter","dataPoint","errorVal","LineWithState","constructor","render","_filterProps","xAxisId","yAxisId","top","left","id","layerClass","dotSize","direction","dataPointFormatter","errorBarOffset","children","activeDot","mainColor","itemDataKey","defaultLineProps","isSsr","label","LineImpl","_resolveDefaultProps","everythingElse","isPanorama","lineSettings","state","computeLinePoints","_ref6","xAxis","yAxis","xAxisTicks","yAxisTicks","bandSize","displayedData","axis","ticks","scale","Line","zAxisId","stackId","barSize","legendPayload","fn","args"],"mappings":"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","sourcesContent":["var _excluded = [\"type\", \"layout\", \"connectNulls\", \"needClip\"],\n  _excluded2 = [\"activeDot\", \"animateNewValues\", \"animationBegin\", \"animationDuration\", \"animationEasing\", \"connectNulls\", \"dot\", \"hide\", \"isAnimationActive\", \"label\", \"legendType\", \"xAxisId\", \"yAxisId\"];\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\n// eslint-disable-next-line max-classes-per-file\nimport * as React from 'react';\nimport { Component, PureComponent, useCallback, useMemo, useRef, useState } from 'react';\nimport { clsx } from 'clsx';\nimport { Curve } from '../shape/Curve';\nimport { Dot } from '../shape/Dot';\nimport { Layer } from '../container/Layer';\nimport { LabelList } from '../component/LabelList';\nimport { SetErrorBarPreferredDirection } from './ErrorBar';\nimport { interpolateNumber, isNullish, uniqueId } from '../util/DataUtils';\nimport { filterProps, isClipDot } from '../util/ReactUtils';\nimport { Global } from '../util/Global';\nimport { getCateCoordinateOfLine, getTooltipNameProp, getValueByDataKey } from '../util/ChartUtils';\nimport { ActivePoints } from '../component/ActivePoints';\nimport { SetTooltipEntrySettings } from '../state/SetTooltipEntrySettings';\nimport { CartesianGraphicalItemContext, SetErrorBarContext } from '../context/CartesianGraphicalItemContext';\nimport { GraphicalItemClipPath, useNeedsClip } from './GraphicalItemClipPath';\nimport { useChartLayout } from '../context/chartLayoutContext';\nimport { useIsPanorama } from '../context/PanoramaContext';\nimport { selectLinePoints } from '../state/selectors/lineSelectors';\nimport { useAppSelector } from '../state/hooks';\nimport { SetLegendPayload } from '../state/SetLegendPayload';\nimport { useAnimationId } from '../util/useAnimationId';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nimport { Animate } from '../animation/Animate';\nimport { usePlotArea } from '../hooks';\n\n/**\n * Internal props, combination of external props + defaultProps + private Recharts state\n */\n\n/**\n * External props, intended for end users to fill in\n */\n\n/**\n * Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.\n */\n\nvar computeLegendPayloadFromAreaData = props => {\n  var {\n    dataKey,\n    name,\n    stroke,\n    legendType,\n    hide\n  } = props;\n  return [{\n    inactive: hide,\n    dataKey,\n    type: legendType,\n    color: stroke,\n    value: getTooltipNameProp(name, dataKey),\n    payload: props\n  }];\n};\nfunction getTooltipEntrySettings(props) {\n  var {\n    dataKey,\n    data,\n    stroke,\n    strokeWidth,\n    fill,\n    name,\n    hide,\n    unit\n  } = props;\n  return {\n    dataDefinedOnItem: data,\n    positions: undefined,\n    settings: {\n      stroke,\n      strokeWidth,\n      fill,\n      dataKey,\n      nameKey: undefined,\n      name: getTooltipNameProp(name, dataKey),\n      hide,\n      type: props.tooltipType,\n      color: props.stroke,\n      unit\n    }\n  };\n}\nvar generateSimpleStrokeDasharray = (totalLength, length) => {\n  return \"\".concat(length, \"px \").concat(totalLength - length, \"px\");\n};\nfunction repeat(lines, count) {\n  var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;\n  var result = [];\n  for (var i = 0; i < count; ++i) {\n    result = [...result, ...linesUnit];\n  }\n  return result;\n}\nvar getStrokeDasharray = (length, totalLength, lines) => {\n  var lineLength = lines.reduce((pre, next) => pre + next);\n\n  // if lineLength is 0 return the default when no strokeDasharray is provided\n  if (!lineLength) {\n    return generateSimpleStrokeDasharray(totalLength, length);\n  }\n  var count = Math.floor(length / lineLength);\n  var remainLength = length % lineLength;\n  var restLength = totalLength - length;\n  var remainLines = [];\n  for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) {\n    if (sum + lines[i] > remainLength) {\n      remainLines = [...lines.slice(0, i), remainLength - sum];\n      break;\n    }\n  }\n  var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];\n  return [...repeat(lines, count), ...remainLines, ...emptyLines].map(line => \"\".concat(line, \"px\")).join(', ');\n};\nfunction renderDotItem(option, props) {\n  var dotItem;\n  if (/*#__PURE__*/React.isValidElement(option)) {\n    dotItem = /*#__PURE__*/React.cloneElement(option, props);\n  } else if (typeof option === 'function') {\n    dotItem = option(props);\n  } else {\n    var className = clsx('recharts-line-dot', typeof option !== 'boolean' ? option.className : '');\n    dotItem = /*#__PURE__*/React.createElement(Dot, _extends({}, props, {\n      className: className\n    }));\n  }\n  return dotItem;\n}\nfunction shouldRenderDots(points, dot) {\n  if (points == null) {\n    return false;\n  }\n  if (dot) {\n    return true;\n  }\n  return points.length === 1;\n}\nfunction Dots(_ref) {\n  var {\n    clipPathId,\n    points,\n    props\n  } = _ref;\n  var {\n    dot,\n    dataKey,\n    needClip\n  } = props;\n  if (!shouldRenderDots(points, dot)) {\n    return null;\n  }\n  var clipDot = isClipDot(dot);\n  var lineProps = filterProps(props, false);\n  var customDotProps = filterProps(dot, true);\n  var dots = points.map((entry, i) => {\n    var dotProps = _objectSpread(_objectSpread(_objectSpread({\n      key: \"dot-\".concat(i),\n      r: 3\n    }, lineProps), customDotProps), {}, {\n      index: i,\n      cx: entry.x,\n      cy: entry.y,\n      dataKey,\n      value: entry.value,\n      payload: entry.payload,\n      points\n    });\n    return renderDotItem(dot, dotProps);\n  });\n  var dotsProps = {\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipDot ? '' : 'dots-').concat(clipPathId, \")\") : null\n  };\n  return /*#__PURE__*/React.createElement(Layer, _extends({\n    className: \"recharts-line-dots\",\n    key: \"dots\"\n  }, dotsProps), dots);\n}\nfunction StaticCurve(_ref2) {\n  var {\n    clipPathId,\n    pathRef,\n    points,\n    strokeDasharray,\n    props,\n    showLabels\n  } = _ref2;\n  var {\n      type,\n      layout,\n      connectNulls,\n      needClip\n    } = props,\n    others = _objectWithoutProperties(props, _excluded);\n  var curveProps = _objectSpread(_objectSpread({}, filterProps(others, true)), {}, {\n    fill: 'none',\n    className: 'recharts-line-curve',\n    clipPath: needClip ? \"url(#clipPath-\".concat(clipPathId, \")\") : null,\n    points,\n    type,\n    layout,\n    connectNulls,\n    strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /*#__PURE__*/React.createElement(Curve, _extends({}, curveProps, {\n    pathRef: pathRef\n  })), /*#__PURE__*/React.createElement(Dots, {\n    points: points,\n    clipPathId: clipPathId,\n    props: props\n  }), showLabels && LabelList.renderCallByParent(props, points));\n}\nfunction getTotalLength(mainCurve) {\n  try {\n    return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;\n  } catch (_unused) {\n    return 0;\n  }\n}\nfunction CurveWithAnimation(_ref3) {\n  var {\n    clipPathId,\n    props,\n    pathRef,\n    previousPointsRef,\n    longestAnimatedLengthRef\n  } = _ref3;\n  var {\n    points,\n    strokeDasharray,\n    isAnimationActive,\n    animationBegin,\n    animationDuration,\n    animationEasing,\n    animateNewValues,\n    width,\n    height,\n    onAnimationEnd,\n    onAnimationStart\n  } = props;\n  var prevPoints = previousPointsRef.current;\n  var animationId = useAnimationId(props, 'recharts-line-');\n  var [isAnimating, setIsAnimating] = useState(false);\n  var handleAnimationEnd = useCallback(() => {\n    if (typeof onAnimationEnd === 'function') {\n      onAnimationEnd();\n    }\n    setIsAnimating(false);\n  }, [onAnimationEnd]);\n  var handleAnimationStart = useCallback(() => {\n    if (typeof onAnimationStart === 'function') {\n      onAnimationStart();\n    }\n    setIsAnimating(true);\n  }, [onAnimationStart]);\n  var totalLength = getTotalLength(pathRef.current);\n  /*\n   * Here we want to detect if the length animation has been interrupted.\n   * For that we keep a reference to the furthest length that has been animated.\n   *\n   * And then, to keep things smooth, we add to it the current length that is being animated right now.\n   *\n   * If we did Math.max then it makes the length animation \"pause\" but we want to keep it smooth\n   * so in case we have some \"leftover\" length from the previous animation we add it to the current length.\n   *\n   * This is not perfect because the animation changes speed due to easing. The default easing is 'ease' which is not linear\n   * and makes it stand out. But it's good enough I suppose.\n   * If we want to fix it then we need to keep track of multiple animations and their easing and timings.\n   *\n   * If you want to see this in action, try to change the dataKey of the line chart while the initial animation is running.\n   * The Line begins with zero length and slowly grows to the full length. While this growth is in progress,\n   * change the dataKey and the Line will continue growing from where it has grown so far.\n   */\n  var startingPoint = longestAnimatedLengthRef.current;\n  return /*#__PURE__*/React.createElement(Animate, {\n    begin: animationBegin,\n    duration: animationDuration,\n    isActive: isAnimationActive,\n    easing: animationEasing,\n    from: {\n      t: 0\n    },\n    to: {\n      t: 1\n    },\n    onAnimationEnd: handleAnimationEnd,\n    onAnimationStart: handleAnimationStart,\n    key: animationId\n  }, _ref4 => {\n    var {\n      t\n    } = _ref4;\n    var interpolator = interpolateNumber(startingPoint, totalLength + startingPoint);\n    var curLength = Math.min(interpolator(t), totalLength);\n    var currentStrokeDasharray;\n    if (strokeDasharray) {\n      var lines = \"\".concat(strokeDasharray).split(/[,\\s]+/gim).map(num => parseFloat(num));\n      currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);\n    } else {\n      currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);\n    }\n    if (prevPoints) {\n      var prevPointsDiffFactor = prevPoints.length / points.length;\n      var stepData = t === 1 ? points : points.map((entry, index) => {\n        var prevPointIndex = Math.floor(index * prevPointsDiffFactor);\n        if (prevPoints[prevPointIndex]) {\n          var prev = prevPoints[prevPointIndex];\n          var interpolatorX = interpolateNumber(prev.x, entry.x);\n          var interpolatorY = interpolateNumber(prev.y, entry.y);\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: interpolatorX(t),\n            y: interpolatorY(t)\n          });\n        }\n\n        // magic number of faking previous x and y location\n        if (animateNewValues) {\n          var _interpolatorX = interpolateNumber(width * 2, entry.x);\n          var _interpolatorY = interpolateNumber(height / 2, entry.y);\n          return _objectSpread(_objectSpread({}, entry), {}, {\n            x: _interpolatorX(t),\n            y: _interpolatorY(t)\n          });\n        }\n        return _objectSpread(_objectSpread({}, entry), {}, {\n          x: entry.x,\n          y: entry.y\n        });\n      });\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = stepData;\n      return /*#__PURE__*/React.createElement(StaticCurve, {\n        props: props,\n        points: stepData,\n        clipPathId: clipPathId,\n        pathRef: pathRef,\n        showLabels: !isAnimating,\n        strokeDasharray: currentStrokeDasharray\n      });\n    }\n\n    /*\n     * Here it is important to wait a little bit with updating the previousPointsRef\n     * before the animation has a time to initialize.\n     * If we set the previous pointsRef immediately, we set it before the Legend height it calculated\n     * and before pathRef is set.\n     * If that happens, the Line will re-render again after Legend had reported its height\n     * which will start a new animation with the previous points as the starting point\n     * which gives the effect of the Line animating slightly upwards (where the animation distance equals the Legend height).\n     * Waiting for t > 0 is indirect but good enough to ensure that the Legend height is calculated and animation works properly.\n     *\n     * Total length similarly is calculated from the pathRef. We should not update the previousPointsRef\n     * before the pathRef is set, otherwise we will have a wrong total length.\n     */\n    if (t > 0 && totalLength > 0) {\n      // eslint-disable-next-line no-param-reassign\n      previousPointsRef.current = points;\n      /*\n       * totalLength is set from a ref and is not updated in the first tick of the animation.\n       * It defaults to zero which is exactly what we want here because we want to grow from zero,\n       * however the same happens when the data change.\n       *\n       * In that case we want to remember the previous length and continue from there, and only animate the shape.\n       *\n       * Therefore the totalLength > 0 check.\n       *\n       * The Animate is about to fire handleAnimationStart which will update the state\n       * and cause a re-render and read a new proper totalLength which will be used in the next tick\n       * and update the longestAnimatedLengthRef.\n       */\n      // eslint-disable-next-line no-param-reassign\n      longestAnimatedLengthRef.current = curLength;\n    }\n    return /*#__PURE__*/React.createElement(StaticCurve, {\n      props: props,\n      points: points,\n      clipPathId: clipPathId,\n      pathRef: pathRef,\n      showLabels: !isAnimating,\n      strokeDasharray: currentStrokeDasharray\n    });\n  });\n}\nfunction RenderCurve(_ref5) {\n  var {\n    clipPathId,\n    props\n  } = _ref5;\n  var {\n    points,\n    isAnimationActive\n  } = props;\n  var previousPointsRef = useRef(null);\n  var longestAnimatedLengthRef = useRef(0);\n  var pathRef = useRef(null);\n  var prevPoints = previousPointsRef.current;\n  if (isAnimationActive && points && points.length && prevPoints !== points) {\n    return /*#__PURE__*/React.createElement(CurveWithAnimation, {\n      props: props,\n      clipPathId: clipPathId,\n      previousPointsRef: previousPointsRef,\n      longestAnimatedLengthRef: longestAnimatedLengthRef,\n      pathRef: pathRef\n    });\n  }\n  return /*#__PURE__*/React.createElement(StaticCurve, {\n    props: props,\n    points: points,\n    clipPathId: clipPathId,\n    pathRef: pathRef,\n    showLabels: true\n  });\n}\nvar errorBarDataPointFormatter = (dataPoint, dataKey) => {\n  return {\n    x: dataPoint.x,\n    y: dataPoint.y,\n    value: dataPoint.value,\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    errorVal: getValueByDataKey(dataPoint.payload, dataKey)\n  };\n};\nclass LineWithState extends Component {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"id\", uniqueId('recharts-line-'));\n  }\n  render() {\n    var _filterProps;\n    var {\n      hide,\n      dot,\n      points,\n      className,\n      xAxisId,\n      yAxisId,\n      top,\n      left,\n      width,\n      height,\n      id,\n      needClip,\n      layout\n    } = this.props;\n    if (hide) {\n      return null;\n    }\n    var layerClass = clsx('recharts-line', className);\n    var clipPathId = isNullish(id) ? this.id : id;\n    var {\n      r = 3,\n      strokeWidth = 2\n    } = (_filterProps = filterProps(dot, false)) !== null && _filterProps !== void 0 ? _filterProps : {\n      r: 3,\n      strokeWidth: 2\n    };\n    var clipDot = isClipDot(dot);\n    var dotSize = r * 2 + strokeWidth;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Layer, {\n      className: layerClass\n    }, needClip && /*#__PURE__*/React.createElement(\"defs\", null, /*#__PURE__*/React.createElement(GraphicalItemClipPath, {\n      clipPathId: clipPathId,\n      xAxisId: xAxisId,\n      yAxisId: yAxisId\n    }), !clipDot && /*#__PURE__*/React.createElement(\"clipPath\", {\n      id: \"clipPath-dots-\".concat(clipPathId)\n    }, /*#__PURE__*/React.createElement(\"rect\", {\n      x: left - dotSize / 2,\n      y: top - dotSize / 2,\n      width: width + dotSize,\n      height: height + dotSize\n    }))), /*#__PURE__*/React.createElement(RenderCurve, {\n      props: this.props,\n      clipPathId: clipPathId\n    }), /*#__PURE__*/React.createElement(SetErrorBarPreferredDirection, {\n      direction: layout === 'horizontal' ? 'y' : 'x'\n    }, /*#__PURE__*/React.createElement(SetErrorBarContext, {\n      xAxisId: xAxisId,\n      yAxisId: yAxisId,\n      data: points,\n      dataPointFormatter: errorBarDataPointFormatter,\n      errorBarOffset: 0\n    }, this.props.children))), /*#__PURE__*/React.createElement(ActivePoints, {\n      activeDot: this.props.activeDot,\n      points: points,\n      mainColor: this.props.stroke,\n      itemDataKey: this.props.dataKey\n    }));\n  }\n}\nvar defaultLineProps = {\n  activeDot: true,\n  animateNewValues: true,\n  animationBegin: 0,\n  animationDuration: 1500,\n  animationEasing: 'ease',\n  connectNulls: false,\n  dot: true,\n  fill: '#fff',\n  hide: false,\n  isAnimationActive: !Global.isSsr,\n  label: false,\n  legendType: 'line',\n  stroke: '#3182bd',\n  strokeWidth: 1,\n  xAxisId: 0,\n  yAxisId: 0\n};\nfunction LineImpl(props) {\n  var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps),\n    {\n      activeDot,\n      animateNewValues,\n      animationBegin,\n      animationDuration,\n      animationEasing,\n      connectNulls,\n      dot,\n      hide,\n      isAnimationActive,\n      label,\n      legendType,\n      xAxisId,\n      yAxisId\n    } = _resolveDefaultProps,\n    everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);\n  var {\n    needClip\n  } = useNeedsClip(xAxisId, yAxisId);\n  var {\n    height,\n    width,\n    x: left,\n    y: top\n  } = usePlotArea();\n  var layout = useChartLayout();\n  var isPanorama = useIsPanorama();\n  var lineSettings = useMemo(() => ({\n    dataKey: props.dataKey,\n    data: props.data\n  }), [props.dataKey, props.data]);\n  var points = useAppSelector(state => selectLinePoints(state, xAxisId, yAxisId, isPanorama, lineSettings));\n  if (layout !== 'horizontal' && layout !== 'vertical') {\n    // Cannot render Line in an unsupported layout\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(LineWithState, _extends({}, everythingElse, {\n    connectNulls: connectNulls,\n    dot: dot,\n    activeDot: activeDot,\n    animateNewValues: animateNewValues,\n    animationBegin: animationBegin,\n    animationDuration: animationDuration,\n    animationEasing: animationEasing,\n    isAnimationActive: isAnimationActive,\n    hide: hide,\n    label: label,\n    legendType: legendType,\n    xAxisId: xAxisId,\n    yAxisId: yAxisId,\n    points: points,\n    layout: layout,\n    height: height,\n    width: width,\n    left: left,\n    top: top,\n    needClip: needClip\n  }));\n}\nexport function computeLinePoints(_ref6) {\n  var {\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataKey,\n    bandSize,\n    displayedData\n  } = _ref6;\n  return displayedData.map((entry, index) => {\n    // @ts-expect-error getValueByDataKey does not validate the output type\n    var value = getValueByDataKey(entry, dataKey);\n    if (layout === 'horizontal') {\n      return {\n        x: getCateCoordinateOfLine({\n          axis: xAxis,\n          ticks: xAxisTicks,\n          bandSize,\n          entry,\n          index\n        }),\n        y: isNullish(value) ? null : yAxis.scale(value),\n        value,\n        payload: entry\n      };\n    }\n    return {\n      x: isNullish(value) ? null : xAxis.scale(value),\n      y: getCateCoordinateOfLine({\n        axis: yAxis,\n        ticks: yAxisTicks,\n        bandSize,\n        entry,\n        index\n      }),\n      value,\n      payload: entry\n    };\n  });\n}\nexport class Line extends PureComponent {\n  render() {\n    // Report all props to Redux store first, before calling any hooks, to avoid circular dependencies.\n    return /*#__PURE__*/React.createElement(CartesianGraphicalItemContext, {\n      type: \"line\",\n      data: this.props.data,\n      xAxisId: this.props.xAxisId,\n      yAxisId: this.props.yAxisId,\n      zAxisId: 0,\n      dataKey: this.props.dataKey\n      // line doesn't stack\n      ,\n      stackId: undefined,\n      hide: this.props.hide,\n      barSize: undefined\n    }, /*#__PURE__*/React.createElement(SetLegendPayload, {\n      legendPayload: computeLegendPayloadFromAreaData(this.props)\n    }), /*#__PURE__*/React.createElement(SetTooltipEntrySettings, {\n      fn: getTooltipEntrySettings,\n      args: this.props\n    }), /*#__PURE__*/React.createElement(LineImpl, this.props));\n  }\n}\n_defineProperty(Line, \"displayName\", 'Line');\n_defineProperty(Line, \"defaultProps\", defaultLineProps);"]},"metadata":{},"sourceType":"module"}