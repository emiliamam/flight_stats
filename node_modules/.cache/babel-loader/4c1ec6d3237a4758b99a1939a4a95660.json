{"ast":null,"code":"import get from 'es-toolkit/compat/get';\nexport var mathSign = value => {\n  if (value === 0) {\n    return 0;\n  }\n\n  if (value > 0) {\n    return 1;\n  }\n\n  return -1;\n};\nexport var isNan = value => {\n  // eslint-disable-next-line eqeqeq\n  return typeof value == 'number' && value != +value;\n};\nexport var isPercent = value => typeof value === 'string' && value.indexOf('%') === value.length - 1;\nexport var isNumber = value => (typeof value === 'number' || value instanceof Number) && !isNan(value);\nexport var isNumOrStr = value => isNumber(value) || typeof value === 'string';\nvar idCounter = 0;\nexport var uniqueId = prefix => {\n  var id = ++idCounter;\n  return \"\".concat(prefix || '').concat(id);\n};\n/**\n * Get percent value of a total value\n * @param {number|string} percent A percent\n * @param {number} totalValue     Total value\n * @param {number} defaultValue   The value returned when percent is undefined or invalid\n * @param {boolean} validate      If set to be true, the result will be validated\n * @return {number} value\n */\n\nexport var getPercentValue = function getPercentValue(percent, totalValue) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isNumber(percent) && typeof percent !== 'string') {\n    return defaultValue;\n  }\n\n  var value;\n\n  if (isPercent(percent)) {\n    if (totalValue == null) {\n      return defaultValue;\n    }\n\n    var index = percent.indexOf('%');\n    value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n  } else {\n    value = +percent;\n  }\n\n  if (isNan(value)) {\n    value = defaultValue;\n  }\n\n  if (validate && totalValue != null && value > totalValue) {\n    value = totalValue;\n  }\n\n  return value;\n};\nexport var hasDuplicate = ary => {\n  if (!Array.isArray(ary)) {\n    return false;\n  }\n\n  var len = ary.length;\n  var cache = {};\n\n  for (var i = 0; i < len; i++) {\n    if (!cache[ary[i]]) {\n      cache[ary[i]] = true;\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * @deprecated instead use {@link interpolate}\n *  this function returns a function that is called immediately in all use-cases.\n *  Instead, use interpolate which returns a number and skips the anonymous function step.\n *  @param numberA The first number\n *  @param numberB The second number\n *  @return A function that returns the interpolated number\n */\n\nexport var interpolateNumber = (numberA, numberB) => {\n  if (isNumber(numberA) && isNumber(numberB)) {\n    return t => numberA + t * (numberB - numberA);\n  }\n\n  return () => numberB;\n};\nexport function interpolate(start, end, t) {\n  if (isNumber(start) && isNumber(end)) {\n    return start + t * (end - start);\n  }\n\n  return end;\n}\nexport function findEntryInArray(ary, specifiedKey, specifiedValue) {\n  if (!ary || !ary.length) {\n    return undefined;\n  }\n\n  return ary.find(entry => entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue);\n}\n/**\n * The least square linear regression\n * @param {Array} data The array of points\n * @returns {Object} The domain of x, and the parameter of linear function\n */\n\nexport var getLinearRegression = data => {\n  if (!data || !data.length) {\n    return null;\n  }\n\n  var len = data.length;\n  var xsum = 0;\n  var ysum = 0;\n  var xysum = 0;\n  var xxsum = 0;\n  var xmin = Infinity;\n  var xmax = -Infinity;\n  var xcurrent = 0;\n  var ycurrent = 0;\n\n  for (var i = 0; i < len; i++) {\n    xcurrent = data[i].cx || 0;\n    ycurrent = data[i].cy || 0;\n    xsum += xcurrent;\n    ysum += ycurrent;\n    xysum += xcurrent * ycurrent;\n    xxsum += xcurrent * xcurrent;\n    xmin = Math.min(xmin, xcurrent);\n    xmax = Math.max(xmax, xcurrent);\n  }\n\n  var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n  return {\n    xmin,\n    xmax,\n    a,\n    b: (ysum - a * xsum) / len\n  };\n};\n/**\n * Checks if the value is null or undefined\n * @param value The value to check\n * @returns true if the value is null or undefined\n */\n\nexport var isNullish = value => {\n  return value === null || typeof value === 'undefined';\n};\n/**\n *Uppercase the first letter of a string\n * @param {string} value The string to uppercase\n * @returns {string} The uppercased string\n */\n\nexport var upperFirst = value => {\n  if (isNullish(value)) {\n    return value;\n  }\n\n  return \"\".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));\n};","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/recharts/es6/util/DataUtils.js"],"names":["get","mathSign","value","isNan","isPercent","indexOf","length","isNumber","Number","isNumOrStr","idCounter","uniqueId","prefix","id","concat","getPercentValue","percent","totalValue","defaultValue","arguments","undefined","validate","index","parseFloat","slice","hasDuplicate","ary","Array","isArray","len","cache","i","interpolateNumber","numberA","numberB","t","interpolate","start","end","findEntryInArray","specifiedKey","specifiedValue","find","entry","getLinearRegression","data","xsum","ysum","xysum","xxsum","xmin","Infinity","xmax","xcurrent","ycurrent","cx","cy","Math","min","max","a","b","isNullish","upperFirst","charAt","toUpperCase"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,uBAAhB;AACA,OAAO,IAAIC,QAAQ,GAAGC,KAAK,IAAI;AAC7B,MAAIA,KAAK,KAAK,CAAd,EAAiB;AACf,WAAO,CAAP;AACD;;AACD,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO,CAAP;AACD;;AACD,SAAO,CAAC,CAAR;AACD,CARM;AASP,OAAO,IAAIC,KAAK,GAAGD,KAAK,IAAI;AAC1B;AACA,SAAO,OAAOA,KAAP,IAAgB,QAAhB,IAA4BA,KAAK,IAAI,CAACA,KAA7C;AACD,CAHM;AAIP,OAAO,IAAIE,SAAS,GAAGF,KAAK,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACG,OAAN,CAAc,GAAd,MAAuBH,KAAK,CAACI,MAAN,GAAe,CAA5F;AACP,OAAO,IAAIC,QAAQ,GAAGL,KAAK,IAAI,CAAC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,YAAYM,MAA/C,KAA0D,CAACL,KAAK,CAACD,KAAD,CAAxF;AACP,OAAO,IAAIO,UAAU,GAAGP,KAAK,IAAIK,QAAQ,CAACL,KAAD,CAAR,IAAmB,OAAOA,KAAP,KAAiB,QAA9D;AACP,IAAIQ,SAAS,GAAG,CAAhB;AACA,OAAO,IAAIC,QAAQ,GAAGC,MAAM,IAAI;AAC9B,MAAIC,EAAE,GAAG,EAAEH,SAAX;AACA,SAAO,GAAGI,MAAH,CAAUF,MAAM,IAAI,EAApB,EAAwBE,MAAxB,CAA+BD,EAA/B,CAAP;AACD,CAHM;AAKP;;;;;;;;;AAQA,OAAO,IAAIE,eAAe,GAAG,SAASA,eAAT,CAAyBC,OAAzB,EAAkCC,UAAlC,EAA8C;AACzE,MAAIC,YAAY,GAAGC,SAAS,CAACb,MAAV,GAAmB,CAAnB,IAAwBa,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAvF;AACA,MAAIE,QAAQ,GAAGF,SAAS,CAACb,MAAV,GAAmB,CAAnB,IAAwBa,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAnF;;AACA,MAAI,CAACZ,QAAQ,CAACS,OAAD,CAAT,IAAsB,OAAOA,OAAP,KAAmB,QAA7C,EAAuD;AACrD,WAAOE,YAAP;AACD;;AACD,MAAIhB,KAAJ;;AACA,MAAIE,SAAS,CAACY,OAAD,CAAb,EAAwB;AACtB,QAAIC,UAAU,IAAI,IAAlB,EAAwB;AACtB,aAAOC,YAAP;AACD;;AACD,QAAII,KAAK,GAAGN,OAAO,CAACX,OAAR,CAAgB,GAAhB,CAAZ;AACAH,IAAAA,KAAK,GAAGe,UAAU,GAAGM,UAAU,CAACP,OAAO,CAACQ,KAAR,CAAc,CAAd,EAAiBF,KAAjB,CAAD,CAAvB,GAAmD,GAA3D;AACD,GAND,MAMO;AACLpB,IAAAA,KAAK,GAAG,CAACc,OAAT;AACD;;AACD,MAAIb,KAAK,CAACD,KAAD,CAAT,EAAkB;AAChBA,IAAAA,KAAK,GAAGgB,YAAR;AACD;;AACD,MAAIG,QAAQ,IAAIJ,UAAU,IAAI,IAA1B,IAAkCf,KAAK,GAAGe,UAA9C,EAA0D;AACxDf,IAAAA,KAAK,GAAGe,UAAR;AACD;;AACD,SAAOf,KAAP;AACD,CAvBM;AAwBP,OAAO,IAAIuB,YAAY,GAAGC,GAAG,IAAI;AAC/B,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAL,EAAyB;AACvB,WAAO,KAAP;AACD;;AACD,MAAIG,GAAG,GAAGH,GAAG,CAACpB,MAAd;AACA,MAAIwB,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC5B,QAAI,CAACD,KAAK,CAACJ,GAAG,CAACK,CAAD,CAAJ,CAAV,EAAoB;AAClBD,MAAAA,KAAK,CAACJ,GAAG,CAACK,CAAD,CAAJ,CAAL,GAAgB,IAAhB;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,CAdM;AAgBP;;;;;;;;;AAQA,OAAO,IAAIC,iBAAiB,GAAG,CAACC,OAAD,EAAUC,OAAV,KAAsB;AACnD,MAAI3B,QAAQ,CAAC0B,OAAD,CAAR,IAAqB1B,QAAQ,CAAC2B,OAAD,CAAjC,EAA4C;AAC1C,WAAOC,CAAC,IAAIF,OAAO,GAAGE,CAAC,IAAID,OAAO,GAAGD,OAAd,CAAvB;AACD;;AACD,SAAO,MAAMC,OAAb;AACD,CALM;AAMP,OAAO,SAASE,WAAT,CAAqBC,KAArB,EAA4BC,GAA5B,EAAiCH,CAAjC,EAAoC;AACzC,MAAI5B,QAAQ,CAAC8B,KAAD,CAAR,IAAmB9B,QAAQ,CAAC+B,GAAD,CAA/B,EAAsC;AACpC,WAAOD,KAAK,GAAGF,CAAC,IAAIG,GAAG,GAAGD,KAAV,CAAhB;AACD;;AACD,SAAOC,GAAP;AACD;AACD,OAAO,SAASC,gBAAT,CAA0Bb,GAA1B,EAA+Bc,YAA/B,EAA6CC,cAA7C,EAA6D;AAClE,MAAI,CAACf,GAAD,IAAQ,CAACA,GAAG,CAACpB,MAAjB,EAAyB;AACvB,WAAOc,SAAP;AACD;;AACD,SAAOM,GAAG,CAACgB,IAAJ,CAASC,KAAK,IAAIA,KAAK,IAAI,CAAC,OAAOH,YAAP,KAAwB,UAAxB,GAAqCA,YAAY,CAACG,KAAD,CAAjD,GAA2D3C,GAAG,CAAC2C,KAAD,EAAQH,YAAR,CAA/D,MAA0FC,cAArH,CAAP;AACD;AAED;;;;;;AAKA,OAAO,IAAIG,mBAAmB,GAAGC,IAAI,IAAI;AACvC,MAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACvC,MAAnB,EAA2B;AACzB,WAAO,IAAP;AACD;;AACD,MAAIuB,GAAG,GAAGgB,IAAI,CAACvC,MAAf;AACA,MAAIwC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,IAAI,GAAGC,QAAX;AACA,MAAIC,IAAI,GAAG,CAACD,QAAZ;AACA,MAAIE,QAAQ,GAAG,CAAf;AACA,MAAIC,QAAQ,GAAG,CAAf;;AACA,OAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,GAApB,EAAyBE,CAAC,EAA1B,EAA8B;AAC5BsB,IAAAA,QAAQ,GAAGR,IAAI,CAACd,CAAD,CAAJ,CAAQwB,EAAR,IAAc,CAAzB;AACAD,IAAAA,QAAQ,GAAGT,IAAI,CAACd,CAAD,CAAJ,CAAQyB,EAAR,IAAc,CAAzB;AACAV,IAAAA,IAAI,IAAIO,QAAR;AACAN,IAAAA,IAAI,IAAIO,QAAR;AACAN,IAAAA,KAAK,IAAIK,QAAQ,GAAGC,QAApB;AACAL,IAAAA,KAAK,IAAII,QAAQ,GAAGA,QAApB;AACAH,IAAAA,IAAI,GAAGO,IAAI,CAACC,GAAL,CAASR,IAAT,EAAeG,QAAf,CAAP;AACAD,IAAAA,IAAI,GAAGK,IAAI,CAACE,GAAL,CAASP,IAAT,EAAeC,QAAf,CAAP;AACD;;AACD,MAAIO,CAAC,GAAG/B,GAAG,GAAGoB,KAAN,KAAgBH,IAAI,GAAGA,IAAvB,GAA8B,CAACjB,GAAG,GAAGmB,KAAN,GAAcF,IAAI,GAAGC,IAAtB,KAA+BlB,GAAG,GAAGoB,KAAN,GAAcH,IAAI,GAAGA,IAApD,CAA9B,GAA0F,CAAlG;AACA,SAAO;AACLI,IAAAA,IADK;AAELE,IAAAA,IAFK;AAGLQ,IAAAA,CAHK;AAILC,IAAAA,CAAC,EAAE,CAACd,IAAI,GAAGa,CAAC,GAAGd,IAAZ,IAAoBjB;AAJlB,GAAP;AAMD,CA9BM;AA+BP;;;;;;AAKA,OAAO,IAAIiC,SAAS,GAAG5D,KAAK,IAAI;AAC9B,SAAOA,KAAK,KAAK,IAAV,IAAkB,OAAOA,KAAP,KAAiB,WAA1C;AACD,CAFM;AAIP;;;;;;AAKA,OAAO,IAAI6D,UAAU,GAAG7D,KAAK,IAAI;AAC/B,MAAI4D,SAAS,CAAC5D,KAAD,CAAb,EAAsB;AACpB,WAAOA,KAAP;AACD;;AACD,SAAO,GAAGY,MAAH,CAAUZ,KAAK,CAAC8D,MAAN,CAAa,CAAb,EAAgBC,WAAhB,EAAV,EAAyCnD,MAAzC,CAAgDZ,KAAK,CAACsB,KAAN,CAAY,CAAZ,CAAhD,CAAP;AACD,CALM","sourcesContent":["import get from 'es-toolkit/compat/get';\nexport var mathSign = value => {\n  if (value === 0) {\n    return 0;\n  }\n  if (value > 0) {\n    return 1;\n  }\n  return -1;\n};\nexport var isNan = value => {\n  // eslint-disable-next-line eqeqeq\n  return typeof value == 'number' && value != +value;\n};\nexport var isPercent = value => typeof value === 'string' && value.indexOf('%') === value.length - 1;\nexport var isNumber = value => (typeof value === 'number' || value instanceof Number) && !isNan(value);\nexport var isNumOrStr = value => isNumber(value) || typeof value === 'string';\nvar idCounter = 0;\nexport var uniqueId = prefix => {\n  var id = ++idCounter;\n  return \"\".concat(prefix || '').concat(id);\n};\n\n/**\n * Get percent value of a total value\n * @param {number|string} percent A percent\n * @param {number} totalValue     Total value\n * @param {number} defaultValue   The value returned when percent is undefined or invalid\n * @param {boolean} validate      If set to be true, the result will be validated\n * @return {number} value\n */\nexport var getPercentValue = function getPercentValue(percent, totalValue) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var validate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  if (!isNumber(percent) && typeof percent !== 'string') {\n    return defaultValue;\n  }\n  var value;\n  if (isPercent(percent)) {\n    if (totalValue == null) {\n      return defaultValue;\n    }\n    var index = percent.indexOf('%');\n    value = totalValue * parseFloat(percent.slice(0, index)) / 100;\n  } else {\n    value = +percent;\n  }\n  if (isNan(value)) {\n    value = defaultValue;\n  }\n  if (validate && totalValue != null && value > totalValue) {\n    value = totalValue;\n  }\n  return value;\n};\nexport var hasDuplicate = ary => {\n  if (!Array.isArray(ary)) {\n    return false;\n  }\n  var len = ary.length;\n  var cache = {};\n  for (var i = 0; i < len; i++) {\n    if (!cache[ary[i]]) {\n      cache[ary[i]] = true;\n    } else {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @deprecated instead use {@link interpolate}\n *  this function returns a function that is called immediately in all use-cases.\n *  Instead, use interpolate which returns a number and skips the anonymous function step.\n *  @param numberA The first number\n *  @param numberB The second number\n *  @return A function that returns the interpolated number\n */\nexport var interpolateNumber = (numberA, numberB) => {\n  if (isNumber(numberA) && isNumber(numberB)) {\n    return t => numberA + t * (numberB - numberA);\n  }\n  return () => numberB;\n};\nexport function interpolate(start, end, t) {\n  if (isNumber(start) && isNumber(end)) {\n    return start + t * (end - start);\n  }\n  return end;\n}\nexport function findEntryInArray(ary, specifiedKey, specifiedValue) {\n  if (!ary || !ary.length) {\n    return undefined;\n  }\n  return ary.find(entry => entry && (typeof specifiedKey === 'function' ? specifiedKey(entry) : get(entry, specifiedKey)) === specifiedValue);\n}\n\n/**\n * The least square linear regression\n * @param {Array} data The array of points\n * @returns {Object} The domain of x, and the parameter of linear function\n */\nexport var getLinearRegression = data => {\n  if (!data || !data.length) {\n    return null;\n  }\n  var len = data.length;\n  var xsum = 0;\n  var ysum = 0;\n  var xysum = 0;\n  var xxsum = 0;\n  var xmin = Infinity;\n  var xmax = -Infinity;\n  var xcurrent = 0;\n  var ycurrent = 0;\n  for (var i = 0; i < len; i++) {\n    xcurrent = data[i].cx || 0;\n    ycurrent = data[i].cy || 0;\n    xsum += xcurrent;\n    ysum += ycurrent;\n    xysum += xcurrent * ycurrent;\n    xxsum += xcurrent * xcurrent;\n    xmin = Math.min(xmin, xcurrent);\n    xmax = Math.max(xmax, xcurrent);\n  }\n  var a = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;\n  return {\n    xmin,\n    xmax,\n    a,\n    b: (ysum - a * xsum) / len\n  };\n};\n/**\n * Checks if the value is null or undefined\n * @param value The value to check\n * @returns true if the value is null or undefined\n */\nexport var isNullish = value => {\n  return value === null || typeof value === 'undefined';\n};\n\n/**\n *Uppercase the first letter of a string\n * @param {string} value The string to uppercase\n * @returns {string} The uppercased string\n */\nexport var upperFirst = value => {\n  if (isNullish(value)) {\n    return value;\n  }\n  return \"\".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));\n};"]},"metadata":{},"sourceType":"module"}