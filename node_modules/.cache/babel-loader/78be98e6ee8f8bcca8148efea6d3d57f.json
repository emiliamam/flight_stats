{"ast":null,"code":"import { createSelector } from 'reselect';\nimport { computeArea } from '../../cartesian/Area';\nimport { selectAxisWithScale, selectStackGroups, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { getBandSizeOfAxis, getNormalizedStackId, isCategoricalAxis } from '../../util/ChartUtils';\n\nvar selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, 'xAxis', xAxisId, isPanorama);\n\nvar selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', xAxisId, isPanorama);\n\nvar selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, 'yAxis', yAxisId, isPanorama);\n\nvar selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', yAxisId, isPanorama);\n\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\n\nvar selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, areaSettings) => {\n  var _stackGroups$stackId;\n\n  var layout = selectChartLayout(state);\n  var isXAxisCategorical = isCategoricalAxis(layout, 'xAxis');\n  var stackGroups;\n\n  if (isXAxisCategorical) {\n    stackGroups = selectStackGroups(state, 'yAxis', yAxisId, isPanorama);\n  } else {\n    stackGroups = selectStackGroups(state, 'xAxis', xAxisId, isPanorama);\n  }\n\n  if (stackGroups == null) {\n    return undefined;\n  }\n\n  var {\n    dataKey,\n    stackId\n  } = areaSettings;\n\n  if (stackId == null) {\n    return undefined;\n  }\n\n  var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;\n  return groups === null || groups === void 0 ? void 0 : groups.find(v => v.key === dataKey);\n};\n\nvar pickAreaSettings = (_state, _xAxisId, _yAxisId, _isPanorama, areaSettings) => areaSettings;\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\n\n\nvar selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaSettings], (graphicalItems, areaSettingsFromProps) => {\n  if (graphicalItems.some(cgis => cgis.type === 'area' && areaSettingsFromProps.dataKey === cgis.dataKey && getNormalizedStackId(areaSettingsFromProps.stackId) === cgis.stackId && areaSettingsFromProps.data === cgis.data)) {\n    /*\n     * now, at least one of the areas has the same dataKey as the one in props.\n     * Is this a perfect match? Maybe not because we could theoretically have two different Areas with the same dataKey\n     * and the same stackId and the same data but still different areas, yes,\n     * but the chances of that happening are ... lowish.\n     *\n     * A proper fix would be to store the areaSettings in a state too, and compare references directly instead of enumerating the properties.\n     */\n    return areaSettingsFromProps;\n  }\n\n  return undefined;\n});\nexport var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize, selectSynchronisedAreaSettings], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref, bandSize, areaSettings) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n\n  if (areaSettings == null || layout !== 'horizontal' && layout !== 'vertical' || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n\n  var {\n    data\n  } = areaSettings;\n  var displayedData;\n\n  if (data && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n\n  if (displayedData == null) {\n    return undefined;\n  } // Where is this supposed to come from? No charts have that as a prop.\n\n\n  var chartBaseValue = undefined;\n  return computeArea({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataStartIndex,\n    areaSettings,\n    stackedData,\n    displayedData,\n    chartBaseValue,\n    bandSize\n  });\n});","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/state/selectors/areaSelectors.js"],"names":["createSelector","computeArea","selectAxisWithScale","selectStackGroups","selectTicksOfGraphicalItem","selectUnfilteredCartesianItems","selectChartLayout","selectChartDataWithIndexesIfNotInPanorama","getBandSizeOfAxis","getNormalizedStackId","isCategoricalAxis","selectXAxisWithScale","state","xAxisId","_yAxisId","isPanorama","selectXAxisTicks","selectYAxisWithScale","_xAxisId","yAxisId","selectYAxisTicks","selectBandSize","layout","xAxis","yAxis","xAxisTicks","yAxisTicks","selectGraphicalItemStackedData","areaSettings","_stackGroups$stackId","isXAxisCategorical","stackGroups","undefined","dataKey","stackId","groups","stackedData","find","v","key","pickAreaSettings","_state","_isPanorama","selectSynchronisedAreaSettings","graphicalItems","areaSettingsFromProps","some","cgis","type","data","selectArea","_ref","bandSize","chartData","dataStartIndex","dataEndIndex","length","displayedData","slice","chartBaseValue"],"mappings":"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","sourcesContent":["import { createSelector } from 'reselect';\nimport { computeArea } from '../../cartesian/Area';\nimport { selectAxisWithScale, selectStackGroups, selectTicksOfGraphicalItem, selectUnfilteredCartesianItems } from './axisSelectors';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { getBandSizeOfAxis, getNormalizedStackId, isCategoricalAxis } from '../../util/ChartUtils';\nvar selectXAxisWithScale = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, 'xAxis', xAxisId, isPanorama);\nvar selectXAxisTicks = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'xAxis', xAxisId, isPanorama);\nvar selectYAxisWithScale = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, 'yAxis', yAxisId, isPanorama);\nvar selectYAxisTicks = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, 'yAxis', yAxisId, isPanorama);\nvar selectBandSize = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {\n  if (isCategoricalAxis(layout, 'xAxis')) {\n    return getBandSizeOfAxis(xAxis, xAxisTicks, false);\n  }\n  return getBandSizeOfAxis(yAxis, yAxisTicks, false);\n});\nvar selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, areaSettings) => {\n  var _stackGroups$stackId;\n  var layout = selectChartLayout(state);\n  var isXAxisCategorical = isCategoricalAxis(layout, 'xAxis');\n  var stackGroups;\n  if (isXAxisCategorical) {\n    stackGroups = selectStackGroups(state, 'yAxis', yAxisId, isPanorama);\n  } else {\n    stackGroups = selectStackGroups(state, 'xAxis', xAxisId, isPanorama);\n  }\n  if (stackGroups == null) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    stackId\n  } = areaSettings;\n  if (stackId == null) {\n    return undefined;\n  }\n  var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;\n  return groups === null || groups === void 0 ? void 0 : groups.find(v => v.key === dataKey);\n};\nvar pickAreaSettings = (_state, _xAxisId, _yAxisId, _isPanorama, areaSettings) => areaSettings;\n\n/*\n * There is a race condition problem because we read some data from props and some from the state.\n * The state is updated through a dispatch and is one render behind,\n * and so we have this weird one tick render where the displayedData in one selector have the old dataKey\n * but the new dataKey in another selector.\n *\n * A proper fix is to either move everything into the state, or read the dataKey always from props\n * - but this is a smaller change.\n */\nvar selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaSettings], (graphicalItems, areaSettingsFromProps) => {\n  if (graphicalItems.some(cgis => cgis.type === 'area' && areaSettingsFromProps.dataKey === cgis.dataKey && getNormalizedStackId(areaSettingsFromProps.stackId) === cgis.stackId && areaSettingsFromProps.data === cgis.data)) {\n    /*\n     * now, at least one of the areas has the same dataKey as the one in props.\n     * Is this a perfect match? Maybe not because we could theoretically have two different Areas with the same dataKey\n     * and the same stackId and the same data but still different areas, yes,\n     * but the chances of that happening are ... lowish.\n     *\n     * A proper fix would be to store the areaSettings in a state too, and compare references directly instead of enumerating the properties.\n     */\n    return areaSettingsFromProps;\n  }\n  return undefined;\n});\nexport var selectArea = createSelector([selectChartLayout, selectXAxisWithScale, selectYAxisWithScale, selectXAxisTicks, selectYAxisTicks, selectGraphicalItemStackedData, selectChartDataWithIndexesIfNotInPanorama, selectBandSize, selectSynchronisedAreaSettings], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref, bandSize, areaSettings) => {\n  var {\n    chartData,\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (areaSettings == null || layout !== 'horizontal' && layout !== 'vertical' || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) {\n    return undefined;\n  }\n  var {\n    data\n  } = areaSettings;\n  var displayedData;\n  if (data && data.length > 0) {\n    displayedData = data;\n  } else {\n    displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);\n  }\n  if (displayedData == null) {\n    return undefined;\n  }\n\n  // Where is this supposed to come from? No charts have that as a prop.\n  var chartBaseValue = undefined;\n  return computeArea({\n    layout,\n    xAxis,\n    yAxis,\n    xAxisTicks,\n    yAxisTicks,\n    dataStartIndex,\n    areaSettings,\n    stackedData,\n    displayedData,\n    chartBaseValue,\n    bandSize\n  });\n});"]},"metadata":{},"sourceType":"module"}