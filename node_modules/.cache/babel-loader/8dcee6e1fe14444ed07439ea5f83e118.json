{"ast":null,"code":"import get from 'es-toolkit/compat/get';\nimport { Children, isValidElement } from 'react';\nimport { isFragment } from 'react-is';\nimport { isNullish } from './DataUtils';\nimport { FilteredElementKeyMap, SVGElementPropKeys, EventKeys } from './types';\nexport var SCALE_TYPES = ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold'];\n/**\n * @deprecated instead find another approach that does not depend on displayName.\n * Get the display name of a component\n * @param  {Object} Comp Specified Component\n * @return {String}      Display name of Component\n */\n\nexport var getDisplayName = Comp => {\n  if (typeof Comp === 'string') {\n    return Comp;\n  }\n\n  if (!Comp) {\n    return '';\n  }\n\n  return Comp.displayName || Comp.name || 'Component';\n}; // `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\n\nvar lastChildren = null;\nvar lastResult = null;\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * @param children do not use\n * @return deprecated do not use\n */\n\nexport var toArray = children => {\n  if (children === lastChildren && Array.isArray(lastResult)) {\n    return lastResult;\n  }\n\n  var result = [];\n  Children.forEach(children, child => {\n    if (isNullish(child)) return;\n\n    if (isFragment(child)) {\n      result = result.concat(toArray(child.props.children));\n    } else {\n      // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n      result.push(child);\n    }\n  });\n  lastResult = result;\n  lastChildren = children;\n  return result;\n};\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * Find and return all matched children by type.\n * `type` must be a React.ComponentType\n *\n * @param children do not use\n * @param type do not use\n * @return deprecated do not use\n */\n\nexport function findAllByType(children, type) {\n  var result = [];\n  var types = [];\n\n  if (Array.isArray(type)) {\n    types = type.map(t => getDisplayName(t));\n  } else {\n    types = [getDisplayName(type)];\n  }\n\n  toArray(children).forEach(child => {\n    var childType = get(child, 'type.displayName') || get(child, 'type.name'); // ts-expect-error toArray and lodash.get are not compatible. Let's get rid of the whole findAllByType function\n\n    if (types.indexOf(childType) !== -1) {\n      result.push(child);\n    }\n  });\n  return result;\n}\nexport var isClipDot = dot => {\n  if (dot && typeof dot === 'object' && 'clipDot' in dot) {\n    return Boolean(dot.clipDot);\n  }\n\n  return true;\n};\n/**\n * Checks if the property is valid to spread onto an SVG element or onto a specific component\n * @param {unknown} property property value currently being compared\n * @param {string} key property key currently being compared\n * @param {boolean} includeEvents if events are included in spreadable props\n * @param {boolean} svgElementType checks against map of SVG element types to attributes\n * @returns {boolean} is prop valid\n */\n\nexport var isValidSpreadableProp = (property, key, includeEvents, svgElementType) => {\n  var _ref;\n  /**\n   * If the svg element type is explicitly included, check against the filtered element key map\n   * to determine if there are attributes that should only exist on that element type.\n   * @todo Add an internal cjs version of https://github.com/wooorm/svg-element-attributes for full coverage.\n   */\n\n\n  var matchingElementTypeKeys = (_ref = svgElementType && (FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType])) !== null && _ref !== void 0 ? _ref : [];\n  return key.startsWith('data-') || typeof property !== 'function' && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);\n};\nexport var filterProps = (props, includeEvents, svgElementType) => {\n  if (!props || typeof props === 'function' || typeof props === 'boolean') {\n    return null;\n  }\n\n  var inputProps = props;\n\n  if ( /*#__PURE__*/isValidElement(props)) {\n    inputProps = props.props;\n  }\n\n  if (typeof inputProps !== 'object' && typeof inputProps !== 'function') {\n    return null;\n  }\n\n  var out = {};\n  /**\n   * Props are blindly spread onto SVG elements. This loop filters out properties that we don't want to spread.\n   * Items filtered out are as follows:\n   *   - functions in properties that are SVG attributes (functions are included when includeEvents is true)\n   *   - props that are SVG attributes but don't matched the passed svgElementType\n   *   - any prop that is not in SVGElementPropKeys (or in EventKeys if includeEvents is true)\n   */\n\n  Object.keys(inputProps).forEach(key => {\n    var _inputProps;\n\n    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {\n      out[key] = inputProps[key];\n    }\n  });\n  return out;\n};","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/util/ReactUtils.js"],"names":["get","Children","isValidElement","isFragment","isNullish","FilteredElementKeyMap","SVGElementPropKeys","EventKeys","SCALE_TYPES","getDisplayName","Comp","displayName","name","lastChildren","lastResult","toArray","children","Array","isArray","result","forEach","child","concat","props","push","findAllByType","type","types","map","t","childType","indexOf","isClipDot","dot","Boolean","clipDot","isValidSpreadableProp","property","key","includeEvents","svgElementType","_ref","matchingElementTypeKeys","startsWith","includes","filterProps","inputProps","out","Object","keys","_inputProps"],"mappings":"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","sourcesContent":["import get from 'es-toolkit/compat/get';\nimport { Children, isValidElement } from 'react';\nimport { isFragment } from 'react-is';\nimport { isNullish } from './DataUtils';\nimport { FilteredElementKeyMap, SVGElementPropKeys, EventKeys } from './types';\nexport var SCALE_TYPES = ['auto', 'linear', 'pow', 'sqrt', 'log', 'identity', 'time', 'band', 'point', 'ordinal', 'quantile', 'quantize', 'utc', 'sequential', 'threshold'];\n\n/**\n * @deprecated instead find another approach that does not depend on displayName.\n * Get the display name of a component\n * @param  {Object} Comp Specified Component\n * @return {String}      Display name of Component\n */\nexport var getDisplayName = Comp => {\n  if (typeof Comp === 'string') {\n    return Comp;\n  }\n  if (!Comp) {\n    return '';\n  }\n  return Comp.displayName || Comp.name || 'Component';\n};\n\n// `toArray` gets called multiple times during the render\n// so we can memoize last invocation (since reference to `children` is the same)\nvar lastChildren = null;\nvar lastResult = null;\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * @param children do not use\n * @return deprecated do not use\n */\nexport var toArray = children => {\n  if (children === lastChildren && Array.isArray(lastResult)) {\n    return lastResult;\n  }\n  var result = [];\n  Children.forEach(children, child => {\n    if (isNullish(child)) return;\n    if (isFragment(child)) {\n      result = result.concat(toArray(child.props.children));\n    } else {\n      // @ts-expect-error this could still be Iterable<ReactNode> and TS does not like that\n      result.push(child);\n    }\n  });\n  lastResult = result;\n  lastChildren = children;\n  return result;\n};\n\n/**\n * @deprecated instead find another approach that does not require reading React Elements from DOM.\n *\n * Find and return all matched children by type.\n * `type` must be a React.ComponentType\n *\n * @param children do not use\n * @param type do not use\n * @return deprecated do not use\n */\nexport function findAllByType(children, type) {\n  var result = [];\n  var types = [];\n  if (Array.isArray(type)) {\n    types = type.map(t => getDisplayName(t));\n  } else {\n    types = [getDisplayName(type)];\n  }\n  toArray(children).forEach(child => {\n    var childType = get(child, 'type.displayName') || get(child, 'type.name');\n    // ts-expect-error toArray and lodash.get are not compatible. Let's get rid of the whole findAllByType function\n    if (types.indexOf(childType) !== -1) {\n      result.push(child);\n    }\n  });\n  return result;\n}\nexport var isClipDot = dot => {\n  if (dot && typeof dot === 'object' && 'clipDot' in dot) {\n    return Boolean(dot.clipDot);\n  }\n  return true;\n};\n\n/**\n * Checks if the property is valid to spread onto an SVG element or onto a specific component\n * @param {unknown} property property value currently being compared\n * @param {string} key property key currently being compared\n * @param {boolean} includeEvents if events are included in spreadable props\n * @param {boolean} svgElementType checks against map of SVG element types to attributes\n * @returns {boolean} is prop valid\n */\nexport var isValidSpreadableProp = (property, key, includeEvents, svgElementType) => {\n  var _ref;\n  /**\n   * If the svg element type is explicitly included, check against the filtered element key map\n   * to determine if there are attributes that should only exist on that element type.\n   * @todo Add an internal cjs version of https://github.com/wooorm/svg-element-attributes for full coverage.\n   */\n  var matchingElementTypeKeys = (_ref = svgElementType && (FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType])) !== null && _ref !== void 0 ? _ref : [];\n  return key.startsWith('data-') || typeof property !== 'function' && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);\n};\nexport var filterProps = (props, includeEvents, svgElementType) => {\n  if (!props || typeof props === 'function' || typeof props === 'boolean') {\n    return null;\n  }\n  var inputProps = props;\n  if (/*#__PURE__*/isValidElement(props)) {\n    inputProps = props.props;\n  }\n  if (typeof inputProps !== 'object' && typeof inputProps !== 'function') {\n    return null;\n  }\n  var out = {};\n\n  /**\n   * Props are blindly spread onto SVG elements. This loop filters out properties that we don't want to spread.\n   * Items filtered out are as follows:\n   *   - functions in properties that are SVG attributes (functions are included when includeEvents is true)\n   *   - props that are SVG attributes but don't matched the passed svgElementType\n   *   - any prop that is not in SVGElementPropKeys (or in EventKeys if includeEvents is true)\n   */\n  Object.keys(inputProps).forEach(key => {\n    var _inputProps;\n    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {\n      out[key] = inputProps[key];\n    }\n  });\n  return out;\n};"]},"metadata":{},"sourceType":"module"}