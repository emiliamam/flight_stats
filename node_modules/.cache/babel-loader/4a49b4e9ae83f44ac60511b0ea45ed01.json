{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, {\n  value: 'Module'\n});\n\nfunction debounce(func, wait = 0, options = {}) {\n  if (typeof options !== 'object') {\n    options = {};\n  }\n\n  let pendingArgs = null;\n  let pendingThis = null;\n  let lastCallTime = null;\n  let debounceStartTime = 0;\n  let timeoutId = null;\n  let lastResult;\n  const {\n    leading = false,\n    trailing = true,\n    maxWait\n  } = options;\n  const hasMaxWait = ('maxWait' in options);\n  const maxWaitMs = hasMaxWait ? Math.max(Number(maxWait) || 0, wait) : 0;\n\n  const invoke = time => {\n    if (pendingArgs !== null) {\n      lastResult = func.apply(pendingThis, pendingArgs);\n    }\n\n    pendingArgs = pendingThis = null;\n    debounceStartTime = time;\n    return lastResult;\n  };\n\n  const handleLeading = time => {\n    debounceStartTime = time;\n    timeoutId = setTimeout(handleTimeout, wait);\n\n    if (leading && pendingArgs !== null) {\n      return invoke(time);\n    }\n\n    return lastResult;\n  };\n\n  const handleTrailing = time => {\n    timeoutId = null;\n\n    if (trailing && pendingArgs !== null) {\n      return invoke(time);\n    }\n\n    return lastResult;\n  };\n\n  const checkCanInvoke = time => {\n    if (lastCallTime === null) {\n      return true;\n    }\n\n    const timeSinceLastCall = time - lastCallTime;\n    const hasDebounceDelayPassed = timeSinceLastCall >= wait || timeSinceLastCall < 0;\n    const hasMaxWaitPassed = hasMaxWait && time - debounceStartTime >= maxWaitMs;\n    return hasDebounceDelayPassed || hasMaxWaitPassed;\n  };\n\n  const calculateRemainingWait = time => {\n    const timeSinceLastCall = lastCallTime === null ? 0 : time - lastCallTime;\n    const remainingDebounceTime = wait - timeSinceLastCall;\n    const remainingMaxWaitTime = maxWaitMs - (time - debounceStartTime);\n    return hasMaxWait ? Math.min(remainingDebounceTime, remainingMaxWaitTime) : remainingDebounceTime;\n  };\n\n  const handleTimeout = () => {\n    const currentTime = Date.now();\n\n    if (checkCanInvoke(currentTime)) {\n      return handleTrailing(currentTime);\n    }\n\n    timeoutId = setTimeout(handleTimeout, calculateRemainingWait(currentTime));\n  };\n\n  const debouncedFunction = function (...args) {\n    const currentTime = Date.now();\n    const canInvoke = checkCanInvoke(currentTime);\n    pendingArgs = args;\n    pendingThis = this;\n    lastCallTime = currentTime;\n\n    if (canInvoke) {\n      if (timeoutId === null) {\n        return handleLeading(currentTime);\n      }\n\n      if (hasMaxWait) {\n        clearTimeout(timeoutId);\n        timeoutId = setTimeout(handleTimeout, wait);\n        return invoke(currentTime);\n      }\n    }\n\n    if (timeoutId === null) {\n      timeoutId = setTimeout(handleTimeout, wait);\n    }\n\n    return lastResult;\n  };\n\n  debouncedFunction.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    debounceStartTime = 0;\n    lastCallTime = pendingArgs = pendingThis = timeoutId = null;\n  };\n\n  debouncedFunction.flush = () => {\n    return timeoutId === null ? lastResult : handleTrailing(Date.now());\n  };\n\n  return debouncedFunction;\n}\n\nexports.debounce = debounce;","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/es-toolkit/dist/compat/function/debounce.js"],"names":["Object","defineProperty","exports","Symbol","toStringTag","value","debounce","func","wait","options","pendingArgs","pendingThis","lastCallTime","debounceStartTime","timeoutId","lastResult","leading","trailing","maxWait","hasMaxWait","maxWaitMs","Math","max","Number","invoke","time","apply","handleLeading","setTimeout","handleTimeout","handleTrailing","checkCanInvoke","timeSinceLastCall","hasDebounceDelayPassed","hasMaxWaitPassed","calculateRemainingWait","remainingDebounceTime","remainingMaxWaitTime","min","currentTime","Date","now","debouncedFunction","args","canInvoke","clearTimeout","cancel","flush"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nfunction debounce(func, wait = 0, options = {}) {\n    if (typeof options !== 'object') {\n        options = {};\n    }\n    let pendingArgs = null;\n    let pendingThis = null;\n    let lastCallTime = null;\n    let debounceStartTime = 0;\n    let timeoutId = null;\n    let lastResult;\n    const { leading = false, trailing = true, maxWait } = options;\n    const hasMaxWait = 'maxWait' in options;\n    const maxWaitMs = hasMaxWait ? Math.max(Number(maxWait) || 0, wait) : 0;\n    const invoke = (time) => {\n        if (pendingArgs !== null) {\n            lastResult = func.apply(pendingThis, pendingArgs);\n        }\n        pendingArgs = pendingThis = null;\n        debounceStartTime = time;\n        return lastResult;\n    };\n    const handleLeading = (time) => {\n        debounceStartTime = time;\n        timeoutId = setTimeout(handleTimeout, wait);\n        if (leading && pendingArgs !== null) {\n            return invoke(time);\n        }\n        return lastResult;\n    };\n    const handleTrailing = (time) => {\n        timeoutId = null;\n        if (trailing && pendingArgs !== null) {\n            return invoke(time);\n        }\n        return lastResult;\n    };\n    const checkCanInvoke = (time) => {\n        if (lastCallTime === null) {\n            return true;\n        }\n        const timeSinceLastCall = time - lastCallTime;\n        const hasDebounceDelayPassed = timeSinceLastCall >= wait || timeSinceLastCall < 0;\n        const hasMaxWaitPassed = hasMaxWait && time - debounceStartTime >= maxWaitMs;\n        return hasDebounceDelayPassed || hasMaxWaitPassed;\n    };\n    const calculateRemainingWait = (time) => {\n        const timeSinceLastCall = lastCallTime === null ? 0 : time - lastCallTime;\n        const remainingDebounceTime = wait - timeSinceLastCall;\n        const remainingMaxWaitTime = maxWaitMs - (time - debounceStartTime);\n        return hasMaxWait ? Math.min(remainingDebounceTime, remainingMaxWaitTime) : remainingDebounceTime;\n    };\n    const handleTimeout = () => {\n        const currentTime = Date.now();\n        if (checkCanInvoke(currentTime)) {\n            return handleTrailing(currentTime);\n        }\n        timeoutId = setTimeout(handleTimeout, calculateRemainingWait(currentTime));\n    };\n    const debouncedFunction = function (...args) {\n        const currentTime = Date.now();\n        const canInvoke = checkCanInvoke(currentTime);\n        pendingArgs = args;\n        pendingThis = this;\n        lastCallTime = currentTime;\n        if (canInvoke) {\n            if (timeoutId === null) {\n                return handleLeading(currentTime);\n            }\n            if (hasMaxWait) {\n                clearTimeout(timeoutId);\n                timeoutId = setTimeout(handleTimeout, wait);\n                return invoke(currentTime);\n            }\n        }\n        if (timeoutId === null) {\n            timeoutId = setTimeout(handleTimeout, wait);\n        }\n        return lastResult;\n    };\n    debouncedFunction.cancel = () => {\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        debounceStartTime = 0;\n        lastCallTime = pendingArgs = pendingThis = timeoutId = null;\n    };\n    debouncedFunction.flush = () => {\n        return timeoutId === null ? lastResult : handleTrailing(Date.now());\n    };\n    return debouncedFunction;\n}\n\nexports.debounce = debounce;\n"]},"metadata":{},"sourceType":"script"}