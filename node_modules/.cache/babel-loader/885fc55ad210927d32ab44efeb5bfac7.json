{"ast":null,"code":"/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { compose, range, memoize, map, reverse } from './util/utils';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\n\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max]; // exchange\n\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n\n  return [validMin, validMax];\n};\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\n\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n\n  var digitCount = getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1); // calculate the middle value of ticks\n\n  var middle = new Decimal(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = compose(map(n => middle.add(new Decimal(n - middleIndex).mul(step)).toNumber()), range);\n  return fn(0, tickCount);\n};\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\n\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; // dirty hack (for recharts' test)\n\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\n\nexport { _calculateStep as calculateStep };\n\nfunction getNiceTickValuesFn(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...range(0, tickCount - 1).map(() => Infinity)] : [...range(0, tickCount - 1).map(() => -Infinity), cormax];\n\n    return min > max ? reverse(_values) : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? reverse(values) : values;\n}\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\n\n\nfunction getTickValuesFixedDomainFn(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var [cormin, cormax] = getValidInterval([min, max]);\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n\n  return min > max ? reverse(values) : values;\n}\n\nexport var getNiceTickValues = memoize(getNiceTickValuesFn);\nexport var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/util/scale/getNiceTickValues.js"],"names":["Decimal","compose","range","memoize","map","reverse","getDigitCount","rangeStep","getValidInterval","_ref","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","value","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","fn","n","_calculateStep","calculateStep","arguments","length","undefined","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValuesFn","_ref2","count","cormin","cormax","Infinity","_values","values","getTickValuesFixedDomainFn","_ref3","round","getNiceTickValues","getTickValuesFixedDomain"],"mappings":"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","sourcesContent":["/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { compose, range, memoize, map, reverse } from './util/utils';\nimport { getDigitCount, rangeStep } from './util/arithmetic';\n\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\nexport var getValidInterval = _ref => {\n  var [min, max] = _ref;\n  var [validMin, validMax] = [min, max];\n\n  // exchange\n  if (min > max) {\n    [validMin, validMax] = [max, min];\n  }\n  return [validMin, validMax];\n};\n\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  roughStep        The rough step calculated by dividing the difference by the tickCount\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step which is easy to understand between two ticks\n */\nexport var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n  var digitCount = getDigitCount(roughStep.toNumber());\n  // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue);\n  // When an integer and a float multiplied, the accuracy of result may be wrong\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? new Decimal(formatStep.toNumber()) : new Decimal(Math.ceil(formatStep.toNumber()));\n};\n\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  value         The minimum value which is also the maximum value\n * @param  tickCount     The count of ticks\n * @param  allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport var getTickOfSingleValue = (value, tickCount, allowDecimals) => {\n  var step = new Decimal(1);\n  // calculate the middle value of ticks\n  var middle = new Decimal(value);\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = compose(map(n => middle.add(new Decimal(n - middleIndex).mul(step)).toNumber()), range);\n  return fn(0, tickCount);\n};\n\n/**\n * Calculate the step\n *\n * @param  min              The minimum value of an interval\n * @param  max              The maximum value of an interval\n * @param  tickCount        The count of ticks\n * @param  allowDecimals    Allow the ticks to be decimals or not\n * @param  correctionFactor A correction factor\n * @return The step, minimum value of ticks, maximum value of ticks\n */\nvar _calculateStep = function calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  }\n\n  // The step which is easy to understand between two ticks\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor);\n\n  // A medial value of ticks\n  var middle;\n\n  // When 0 is inside the interval, 0 should be a tick\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2);\n    // minus modulo value\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return _calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n  return {\n    step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n};\n\n/**\n * Calculate the ticks of an interval. Ticks can appear outside the interval\n * if it makes them more rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nexport { _calculateStep as calculateStep };\nfunction getNiceTickValuesFn(_ref2) {\n  var [min, max] = _ref2;\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin, ...range(0, tickCount - 1).map(() => Infinity)] : [...range(0, tickCount - 1).map(() => -Infinity), cormax];\n    return min > max ? reverse(_values) : _values;\n  }\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  // Get the step between two ticks\n  var {\n    step,\n    tickMin,\n    tickMax\n  } = _calculateStep(cormin, cormax, count, allowDecimals, 0);\n  var values = rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? reverse(values) : values;\n}\n\n/**\n * Calculate the ticks of an interval.\n * Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.\n *\n * @param tuple of [min,max] min: The minimum value, max: The maximum value\n * @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.\n * @param allowDecimals Allow the ticks to be decimals or not\n * @return array of ticks\n */\nfunction getTickValuesFixedDomainFn(_ref3, tickCount) {\n  var [min, max] = _ref3;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var [cormin, cormax] = getValidInterval([min, max]);\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n  if (cormin === cormax) {\n    return [cormin];\n  }\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [...rangeStep(new Decimal(cormin), new Decimal(cormax), step), cormax];\n  if (allowDecimals === false) {\n    /*\n     * allowDecimals is false means that we want to have integer ticks.\n     * The step is guaranteed to be an integer in the code above which is great start\n     * but when the first step is not an integer, it will start stepping from a decimal value anyway.\n     * So we need to round all the values to integers after the fact.\n     */\n    values = values.map(value => Math.round(value));\n  }\n  return min > max ? reverse(values) : values;\n}\nexport var getNiceTickValues = memoize(getNiceTickValuesFn);\nexport var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);"]},"metadata":{},"sourceType":"module"}