{"ast":null,"code":"import { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\n\nvar noop = () => {};\n\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n\n      if (syncMethod === 'index') {\n        dispatch(action); // This is the default behaviour, we don't need to do anything else.\n\n        return;\n      }\n\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n\n      var activeTick;\n\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        }; // Call a callback function. If there is an application specific algorithm\n\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n\n      var {\n        coordinate\n      } = action.payload;\n\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined\n        }));\n        return;\n      }\n\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label\n      });\n      dispatch(syncAction);\n    };\n\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\n\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\n\n\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\n\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/synchronisation/useChartSynchronisation.js"],"names":["useEffect","useAppDispatch","useAppSelector","selectEventEmitter","selectSyncId","selectSyncMethod","BRUSH_SYNC_EVENT","eventCenter","TOOLTIP_SYNC_EVENT","createEventEmitter","setSyncInteraction","selectTooltipDataKey","selectTooltipAxisTicks","selectSynchronisedTooltipState","useChartLayout","useViewBox","setDataStartEndIndexes","noop","useTooltipSyncEventsListener","mySyncId","myEventEmitter","dispatch","syncMethod","tooltipTicks","layout","viewBox","className","state","rootProps","listener","incomingSyncId","action","emitter","activeTick","syncMethodParam","activeTooltipIndex","payload","index","undefined","Number","isTooltipActive","active","activeIndex","activeLabel","label","activeDataKey","dataKey","activeCoordinate","coordinate","find","tick","String","value","x","y","validateChartX","Math","min","width","validateChartY","height","syncAction","on","off","useBrushSyncEventsListener","useSynchronisedEventsFromOtherCharts","useTooltipChartSynchronisation","tooltipEventType","trigger","eventEmitterSymbol","syncId","tooltipState","isReceivingSynchronisation","emit","useBrushChartSynchronisation","brushStartIndex","chartData","dataStartIndex","brushEndIndex","dataEndIndex","startIndex","endIndex"],"mappings":"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","sourcesContent":["import { useEffect } from 'react';\nimport { useAppDispatch, useAppSelector } from '../state/hooks';\nimport { selectEventEmitter, selectSyncId, selectSyncMethod } from '../state/selectors/rootPropsSelectors';\nimport { BRUSH_SYNC_EVENT, eventCenter, TOOLTIP_SYNC_EVENT } from '../util/Events';\nimport { createEventEmitter } from '../state/optionsSlice';\nimport { setSyncInteraction } from '../state/tooltipSlice';\nimport { selectTooltipDataKey } from '../state/selectors/selectors';\nimport { selectTooltipAxisTicks } from '../state/selectors/tooltipSelectors';\nimport { selectSynchronisedTooltipState } from './syncSelectors';\nimport { useChartLayout, useViewBox } from '../context/chartLayoutContext';\nimport { setDataStartEndIndexes } from '../state/chartDataSlice';\nvar noop = () => {};\nfunction useTooltipSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipTicks = useAppSelector(selectTooltipAxisTicks);\n  var layout = useChartLayout();\n  var viewBox = useViewBox();\n  var className = useAppSelector(state => state.rootProps.className);\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId !== incomingSyncId) {\n        // This event is not for this chart\n        return;\n      }\n      if (syncMethod === 'index') {\n        dispatch(action);\n        // This is the default behaviour, we don't need to do anything else.\n        return;\n      }\n      if (tooltipTicks == null) {\n        // for the other two sync methods, we need the ticks to be available\n        return;\n      }\n      var activeTick;\n      if (typeof syncMethod === 'function') {\n        /*\n         * This is what the data shape in 2.x CategoricalChartState used to look like.\n         * In 3.x we store things differently but let's try to keep the old shape for compatibility.\n         */\n        var syncMethodParam = {\n          activeTooltipIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          isTooltipActive: action.payload.active,\n          activeIndex: action.payload.index == null ? undefined : Number(action.payload.index),\n          activeLabel: action.payload.label,\n          activeDataKey: action.payload.dataKey,\n          activeCoordinate: action.payload.coordinate\n        };\n        // Call a callback function. If there is an application specific algorithm\n        var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);\n        activeTick = tooltipTicks[activeTooltipIndex];\n      } else if (syncMethod === 'value') {\n        // labels are always strings, tick.value might be a string or a number, depending on axis type\n        activeTick = tooltipTicks.find(tick => String(tick.value) === action.payload.label);\n      }\n      var {\n        coordinate\n      } = action.payload;\n      if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {\n        dispatch(setSyncInteraction({\n          active: false,\n          coordinate: undefined,\n          dataKey: undefined,\n          index: null,\n          label: undefined\n        }));\n        return;\n      }\n      var {\n        x,\n        y\n      } = coordinate;\n      var validateChartX = Math.min(x, viewBox.x + viewBox.width);\n      var validateChartY = Math.min(y, viewBox.y + viewBox.height);\n      var activeCoordinate = {\n        x: layout === 'horizontal' ? activeTick.coordinate : validateChartX,\n        y: layout === 'horizontal' ? validateChartY : activeTick.coordinate\n      };\n      var syncAction = setSyncInteraction({\n        active: action.payload.active,\n        coordinate: activeCoordinate,\n        dataKey: action.payload.dataKey,\n        index: String(activeTick.index),\n        label: action.payload.label\n      });\n      dispatch(syncAction);\n    };\n    eventCenter.on(TOOLTIP_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(TOOLTIP_SYNC_EVENT, listener);\n    };\n  }, [className, dispatch, myEventEmitter, mySyncId, syncMethod, tooltipTicks, layout, viewBox]);\n}\nfunction useBrushSyncEventsListener() {\n  var mySyncId = useAppSelector(selectSyncId);\n  var myEventEmitter = useAppSelector(selectEventEmitter);\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    if (mySyncId == null) {\n      // This chart is not synchronised with any other chart so we don't need to listen for any events.\n      return noop;\n    }\n    var listener = (incomingSyncId, action, emitter) => {\n      if (myEventEmitter === emitter) {\n        // We don't want to dispatch actions that we sent ourselves.\n        return;\n      }\n      if (mySyncId === incomingSyncId) {\n        dispatch(setDataStartEndIndexes(action));\n      }\n    };\n    eventCenter.on(BRUSH_SYNC_EVENT, listener);\n    return () => {\n      eventCenter.off(BRUSH_SYNC_EVENT, listener);\n    };\n  }, [dispatch, myEventEmitter, mySyncId]);\n}\n\n/**\n * Will receive synchronisation events from other charts.\n *\n * Reads syncMethod from state and decides how to synchronise the tooltip based on that.\n *\n * @returns void\n */\nexport function useSynchronisedEventsFromOtherCharts() {\n  var dispatch = useAppDispatch();\n  useEffect(() => {\n    dispatch(createEventEmitter());\n  }, [dispatch]);\n  useTooltipSyncEventsListener();\n  useBrushSyncEventsListener();\n}\n\n/**\n * Will send events to other charts.\n * If syncId is undefined, no events will be sent.\n *\n * This ignores the syncMethod, because that is set and computed on the receiving end.\n *\n * @param tooltipEventType from Tooltip\n * @param trigger from Tooltip\n * @param activeCoordinate from state\n * @param activeLabel from state\n * @param activeIndex from state\n * @param isTooltipActive from state\n * @returns void\n */\nexport function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {\n  var activeDataKey = useAppSelector(state => selectTooltipDataKey(state, tooltipEventType, trigger));\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var syncId = useAppSelector(selectSyncId);\n  var syncMethod = useAppSelector(selectSyncMethod);\n  var tooltipState = useAppSelector(selectSynchronisedTooltipState);\n  var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;\n  useEffect(() => {\n    if (isReceivingSynchronisation) {\n      /*\n       * This chart currently has active tooltip, synchronised from another chart.\n       * Let's not send any outgoing synchronisation events while that's happening\n       * to avoid infinite loops.\n       */\n      return;\n    }\n    if (syncId == null) {\n      /*\n       * syncId is not set, means that this chart is not synchronised with any other chart,\n       * means we don't need to send synchronisation events\n       */\n      return;\n    }\n    if (eventEmitterSymbol == null) {\n      /*\n       * When using Recharts internal hooks and selectors outside charts context,\n       * these properties will be undefined. Let's return silently instead of throwing an error.\n       */\n      return;\n    }\n    var syncAction = setSyncInteraction({\n      active: isTooltipActive,\n      coordinate: activeCoordinate,\n      dataKey: activeDataKey,\n      index: activeIndex,\n      label: typeof activeLabel === 'number' ? String(activeLabel) : activeLabel\n    });\n    eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [isReceivingSynchronisation, activeCoordinate, activeDataKey, activeIndex, activeLabel, eventEmitterSymbol, syncId, syncMethod, isTooltipActive]);\n}\nexport function useBrushChartSynchronisation() {\n  var syncId = useAppSelector(selectSyncId);\n  var eventEmitterSymbol = useAppSelector(selectEventEmitter);\n  var brushStartIndex = useAppSelector(state => state.chartData.dataStartIndex);\n  var brushEndIndex = useAppSelector(state => state.chartData.dataEndIndex);\n  useEffect(() => {\n    if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) {\n      return;\n    }\n    var syncAction = {\n      startIndex: brushStartIndex,\n      endIndex: brushEndIndex\n    };\n    eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);\n  }, [brushEndIndex, brushStartIndex, eventEmitterSymbol, syncId]);\n}"]},"metadata":{},"sourceType":"module"}