{"ast":null,"code":"function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nimport * as React from 'react';\nimport { clsx } from 'clsx';\nimport { filterProps } from '../util/ReactUtils';\nimport { polarToCartesian, RADIAN } from '../util/PolarUtils';\nimport { getPercentValue, mathSign } from '../util/DataUtils';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\n\nvar getDeltaAngle = (startAngle, endAngle) => {\n  var sign = mathSign(endAngle - startAngle);\n  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);\n  return sign * deltaAngle;\n};\n\nvar getTangentCircle = _ref => {\n  var {\n    cx,\n    cy,\n    radius,\n    angle,\n    sign,\n    isExternal,\n    cornerRadius,\n    cornerIsExternal\n  } = _ref;\n  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;\n  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;\n  var centerAngle = cornerIsExternal ? angle : angle + sign * theta;\n  var center = polarToCartesian(cx, cy, centerRadius, centerAngle); // The coordinate of point which is tangent to the circle\n\n  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle); // The coordinate of point which is tangent to the radius line\n\n  var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;\n  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);\n  return {\n    center,\n    circleTangency,\n    lineTangency,\n    theta\n  };\n};\n\nvar getSectorPath = _ref2 => {\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    startAngle,\n    endAngle\n  } = _ref2;\n  var angle = getDeltaAngle(startAngle, endAngle); // When the angle of sector equals to 360, star point and end point coincide\n\n  var tempEndAngle = startAngle + angle;\n  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);\n  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);\n  var path = \"M \".concat(outerStartPoint.x, \",\").concat(outerStartPoint.y, \"\\n    A \").concat(outerRadius, \",\").concat(outerRadius, \",0,\\n    \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle > tempEndAngle), \",\\n    \").concat(outerEndPoint.x, \",\").concat(outerEndPoint.y, \"\\n  \");\n\n  if (innerRadius > 0) {\n    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);\n    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);\n    path += \"L \".concat(innerEndPoint.x, \",\").concat(innerEndPoint.y, \"\\n            A \").concat(innerRadius, \",\").concat(innerRadius, \",0,\\n            \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle <= tempEndAngle), \",\\n            \").concat(innerStartPoint.x, \",\").concat(innerStartPoint.y, \" Z\");\n  } else {\n    path += \"L \".concat(cx, \",\").concat(cy, \" Z\");\n  }\n\n  return path;\n};\n\nvar getSectorWithCorner = _ref3 => {\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    forceCornerRadius,\n    cornerIsExternal,\n    startAngle,\n    endAngle\n  } = _ref3;\n  var sign = mathSign(endAngle - startAngle);\n  var {\n    circleTangency: soct,\n    lineTangency: solt,\n    theta: sot\n  } = getTangentCircle({\n    cx,\n    cy,\n    radius: outerRadius,\n    angle: startAngle,\n    sign,\n    cornerRadius,\n    cornerIsExternal\n  });\n  var {\n    circleTangency: eoct,\n    lineTangency: eolt,\n    theta: eot\n  } = getTangentCircle({\n    cx,\n    cy,\n    radius: outerRadius,\n    angle: endAngle,\n    sign: -sign,\n    cornerRadius,\n    cornerIsExternal\n  });\n  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;\n\n  if (outerArcAngle < 0) {\n    if (forceCornerRadius) {\n      return \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(cornerRadius * 2, \",0\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(-cornerRadius * 2, \",0\\n      \");\n    }\n\n    return getSectorPath({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    });\n  }\n\n  var path = \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(soct.x, \",\").concat(soct.y, \"\\n    A\").concat(outerRadius, \",\").concat(outerRadius, \",0,\").concat(+(outerArcAngle > 180), \",\").concat(+(sign < 0), \",\").concat(eoct.x, \",\").concat(eoct.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eolt.x, \",\").concat(eolt.y, \"\\n  \");\n\n  if (innerRadius > 0) {\n    var {\n      circleTangency: sict,\n      lineTangency: silt,\n      theta: sit\n    } = getTangentCircle({\n      cx,\n      cy,\n      radius: innerRadius,\n      angle: startAngle,\n      sign,\n      isExternal: true,\n      cornerRadius,\n      cornerIsExternal\n    });\n    var {\n      circleTangency: eict,\n      lineTangency: eilt,\n      theta: eit\n    } = getTangentCircle({\n      cx,\n      cy,\n      radius: innerRadius,\n      angle: endAngle,\n      sign: -sign,\n      isExternal: true,\n      cornerRadius,\n      cornerIsExternal\n    });\n    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;\n\n    if (innerArcAngle < 0 && cornerRadius === 0) {\n      return \"\".concat(path, \"L\").concat(cx, \",\").concat(cy, \"Z\");\n    }\n\n    path += \"L\".concat(eilt.x, \",\").concat(eilt.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eict.x, \",\").concat(eict.y, \"\\n      A\").concat(innerRadius, \",\").concat(innerRadius, \",0,\").concat(+(innerArcAngle > 180), \",\").concat(+(sign > 0), \",\").concat(sict.x, \",\").concat(sict.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(silt.x, \",\").concat(silt.y, \"Z\");\n  } else {\n    path += \"L\".concat(cx, \",\").concat(cy, \"Z\");\n  }\n\n  return path;\n};\n\nvar defaultProps = {\n  cx: 0,\n  cy: 0,\n  innerRadius: 0,\n  outerRadius: 0,\n  startAngle: 0,\n  endAngle: 0,\n  cornerRadius: 0,\n  forceCornerRadius: false,\n  cornerIsExternal: false\n};\nexport var Sector = sectorProps => {\n  var props = resolveDefaultProps(sectorProps, defaultProps);\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    forceCornerRadius,\n    cornerIsExternal,\n    startAngle,\n    endAngle,\n    className\n  } = props;\n\n  if (outerRadius < innerRadius || startAngle === endAngle) {\n    return null;\n  }\n\n  var layerClass = clsx('recharts-sector', className);\n  var deltaRadius = outerRadius - innerRadius;\n  var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);\n  var path;\n\n  if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {\n    path = getSectorWithCorner({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      cornerRadius: Math.min(cr, deltaRadius / 2),\n      forceCornerRadius,\n      cornerIsExternal,\n      startAngle,\n      endAngle\n    });\n  } else {\n    path = getSectorPath({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    });\n  }\n\n  return /*#__PURE__*/React.createElement(\"path\", _extends({}, filterProps(props, true), {\n    className: layerClass,\n    d: path\n  }));\n};","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/shape/Sector.js"],"names":["_extends","Object","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","React","clsx","filterProps","polarToCartesian","RADIAN","getPercentValue","mathSign","resolveDefaultProps","getDeltaAngle","startAngle","endAngle","sign","deltaAngle","Math","min","abs","getTangentCircle","_ref","cx","cy","radius","angle","isExternal","cornerRadius","cornerIsExternal","centerRadius","theta","asin","centerAngle","center","circleTangency","lineTangencyAngle","lineTangency","cos","getSectorPath","_ref2","innerRadius","outerRadius","tempEndAngle","outerStartPoint","outerEndPoint","path","concat","x","y","innerStartPoint","innerEndPoint","getSectorWithCorner","_ref3","forceCornerRadius","soct","solt","sot","eoct","eolt","eot","outerArcAngle","sict","silt","sit","eict","eilt","eit","innerArcAngle","defaultProps","Sector","sectorProps","props","className","layerClass","deltaRadius","cr","createElement","d"],"mappings":"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","sourcesContent":["function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport * as React from 'react';\nimport { clsx } from 'clsx';\nimport { filterProps } from '../util/ReactUtils';\nimport { polarToCartesian, RADIAN } from '../util/PolarUtils';\nimport { getPercentValue, mathSign } from '../util/DataUtils';\nimport { resolveDefaultProps } from '../util/resolveDefaultProps';\nvar getDeltaAngle = (startAngle, endAngle) => {\n  var sign = mathSign(endAngle - startAngle);\n  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);\n  return sign * deltaAngle;\n};\nvar getTangentCircle = _ref => {\n  var {\n    cx,\n    cy,\n    radius,\n    angle,\n    sign,\n    isExternal,\n    cornerRadius,\n    cornerIsExternal\n  } = _ref;\n  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;\n  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;\n  var centerAngle = cornerIsExternal ? angle : angle + sign * theta;\n  var center = polarToCartesian(cx, cy, centerRadius, centerAngle);\n  // The coordinate of point which is tangent to the circle\n  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);\n  // The coordinate of point which is tangent to the radius line\n  var lineTangencyAngle = cornerIsExternal ? angle - sign * theta : angle;\n  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);\n  return {\n    center,\n    circleTangency,\n    lineTangency,\n    theta\n  };\n};\nvar getSectorPath = _ref2 => {\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    startAngle,\n    endAngle\n  } = _ref2;\n  var angle = getDeltaAngle(startAngle, endAngle);\n\n  // When the angle of sector equals to 360, star point and end point coincide\n  var tempEndAngle = startAngle + angle;\n  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);\n  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);\n  var path = \"M \".concat(outerStartPoint.x, \",\").concat(outerStartPoint.y, \"\\n    A \").concat(outerRadius, \",\").concat(outerRadius, \",0,\\n    \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle > tempEndAngle), \",\\n    \").concat(outerEndPoint.x, \",\").concat(outerEndPoint.y, \"\\n  \");\n  if (innerRadius > 0) {\n    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);\n    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);\n    path += \"L \".concat(innerEndPoint.x, \",\").concat(innerEndPoint.y, \"\\n            A \").concat(innerRadius, \",\").concat(innerRadius, \",0,\\n            \").concat(+(Math.abs(angle) > 180), \",\").concat(+(startAngle <= tempEndAngle), \",\\n            \").concat(innerStartPoint.x, \",\").concat(innerStartPoint.y, \" Z\");\n  } else {\n    path += \"L \".concat(cx, \",\").concat(cy, \" Z\");\n  }\n  return path;\n};\nvar getSectorWithCorner = _ref3 => {\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    forceCornerRadius,\n    cornerIsExternal,\n    startAngle,\n    endAngle\n  } = _ref3;\n  var sign = mathSign(endAngle - startAngle);\n  var {\n    circleTangency: soct,\n    lineTangency: solt,\n    theta: sot\n  } = getTangentCircle({\n    cx,\n    cy,\n    radius: outerRadius,\n    angle: startAngle,\n    sign,\n    cornerRadius,\n    cornerIsExternal\n  });\n  var {\n    circleTangency: eoct,\n    lineTangency: eolt,\n    theta: eot\n  } = getTangentCircle({\n    cx,\n    cy,\n    radius: outerRadius,\n    angle: endAngle,\n    sign: -sign,\n    cornerRadius,\n    cornerIsExternal\n  });\n  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;\n  if (outerArcAngle < 0) {\n    if (forceCornerRadius) {\n      return \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(cornerRadius * 2, \",0\\n        a\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,1,\").concat(-cornerRadius * 2, \",0\\n      \");\n    }\n    return getSectorPath({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    });\n  }\n  var path = \"M \".concat(solt.x, \",\").concat(solt.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(soct.x, \",\").concat(soct.y, \"\\n    A\").concat(outerRadius, \",\").concat(outerRadius, \",0,\").concat(+(outerArcAngle > 180), \",\").concat(+(sign < 0), \",\").concat(eoct.x, \",\").concat(eoct.y, \"\\n    A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eolt.x, \",\").concat(eolt.y, \"\\n  \");\n  if (innerRadius > 0) {\n    var {\n      circleTangency: sict,\n      lineTangency: silt,\n      theta: sit\n    } = getTangentCircle({\n      cx,\n      cy,\n      radius: innerRadius,\n      angle: startAngle,\n      sign,\n      isExternal: true,\n      cornerRadius,\n      cornerIsExternal\n    });\n    var {\n      circleTangency: eict,\n      lineTangency: eilt,\n      theta: eit\n    } = getTangentCircle({\n      cx,\n      cy,\n      radius: innerRadius,\n      angle: endAngle,\n      sign: -sign,\n      isExternal: true,\n      cornerRadius,\n      cornerIsExternal\n    });\n    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;\n    if (innerArcAngle < 0 && cornerRadius === 0) {\n      return \"\".concat(path, \"L\").concat(cx, \",\").concat(cy, \"Z\");\n    }\n    path += \"L\".concat(eilt.x, \",\").concat(eilt.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(eict.x, \",\").concat(eict.y, \"\\n      A\").concat(innerRadius, \",\").concat(innerRadius, \",0,\").concat(+(innerArcAngle > 180), \",\").concat(+(sign > 0), \",\").concat(sict.x, \",\").concat(sict.y, \"\\n      A\").concat(cornerRadius, \",\").concat(cornerRadius, \",0,0,\").concat(+(sign < 0), \",\").concat(silt.x, \",\").concat(silt.y, \"Z\");\n  } else {\n    path += \"L\".concat(cx, \",\").concat(cy, \"Z\");\n  }\n  return path;\n};\nvar defaultProps = {\n  cx: 0,\n  cy: 0,\n  innerRadius: 0,\n  outerRadius: 0,\n  startAngle: 0,\n  endAngle: 0,\n  cornerRadius: 0,\n  forceCornerRadius: false,\n  cornerIsExternal: false\n};\nexport var Sector = sectorProps => {\n  var props = resolveDefaultProps(sectorProps, defaultProps);\n  var {\n    cx,\n    cy,\n    innerRadius,\n    outerRadius,\n    cornerRadius,\n    forceCornerRadius,\n    cornerIsExternal,\n    startAngle,\n    endAngle,\n    className\n  } = props;\n  if (outerRadius < innerRadius || startAngle === endAngle) {\n    return null;\n  }\n  var layerClass = clsx('recharts-sector', className);\n  var deltaRadius = outerRadius - innerRadius;\n  var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);\n  var path;\n  if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {\n    path = getSectorWithCorner({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      cornerRadius: Math.min(cr, deltaRadius / 2),\n      forceCornerRadius,\n      cornerIsExternal,\n      startAngle,\n      endAngle\n    });\n  } else {\n    path = getSectorPath({\n      cx,\n      cy,\n      innerRadius,\n      outerRadius,\n      startAngle,\n      endAngle\n    });\n  }\n  return /*#__PURE__*/React.createElement(\"path\", _extends({}, filterProps(props, true), {\n    className: layerClass,\n    d: path\n  }));\n};"]},"metadata":{},"sourceType":"module"}