{"ast":null,"code":"import { MAX_VALUE_REG, MIN_VALUE_REG } from './ChartUtils';\nimport { isNumber } from './DataUtils';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function isWellFormedNumberDomain(v) {\n  if (Array.isArray(v) && v.length === 2) {\n    var [min, max] = v;\n\n    if (isWellBehavedNumber(min) && isWellBehavedNumber(max)) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {\n  if (allowDataOverflow) {\n    // If the data are allowed to overflow - we're fine with whatever user provided\n    return providedDomain;\n  }\n  /*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */\n\n\n  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];\n}\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\n\nexport function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {\n  if (!allowDataOverflow) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n\n  if (typeof userDomain === 'function') {\n    // The user function expects the data to be provided as an argument\n    return undefined;\n  }\n\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n\n    if (isWellBehavedNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n\n    if (isWellBehavedNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n\n    var candidate = [finalMin, finalMax];\n\n    if (isWellFormedNumberDomain(candidate)) {\n      return candidate;\n    }\n  }\n\n  return undefined;\n}\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\n\nexport function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {\n  if (!allowDataOverflow && dataDomain == null) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n\n  if (typeof userDomain === 'function' && dataDomain != null) {\n    try {\n      var result = userDomain(dataDomain, allowDataOverflow);\n\n      if (isWellFormedNumberDomain(result)) {\n        return extendDomain(result, dataDomain, allowDataOverflow);\n      }\n    } catch (_unused) {\n      /* ignore the exception and compute domain from data later */\n    }\n  }\n\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n\n    if (providedMin === 'auto') {\n      if (dataDomain != null) {\n        finalMin = Math.min(...dataDomain);\n      }\n    } else if (isNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);\n        }\n      } catch (_unused2) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMin === 'string' && MIN_VALUE_REG.test(providedMin)) {\n      var match = MIN_VALUE_REG.exec(providedMin);\n\n      if (match == null || dataDomain == null) {\n        finalMin = undefined;\n      } else {\n        var value = +match[1];\n        finalMin = dataDomain[0] - value;\n      }\n    } else {\n      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];\n    }\n\n    if (providedMax === 'auto') {\n      if (dataDomain != null) {\n        finalMax = Math.max(...dataDomain);\n      }\n    } else if (isNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);\n        }\n      } catch (_unused3) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMax === 'string' && MAX_VALUE_REG.test(providedMax)) {\n      var _match = MAX_VALUE_REG.exec(providedMax);\n\n      if (_match == null || dataDomain == null) {\n        finalMax = undefined;\n      } else {\n        var _value = +_match[1];\n\n        finalMax = dataDomain[1] + _value;\n      }\n    } else {\n      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];\n    }\n\n    var candidate = [finalMin, finalMax];\n\n    if (isWellFormedNumberDomain(candidate)) {\n      if (dataDomain == null) {\n        return candidate;\n      }\n\n      return extendDomain(candidate, dataDomain, allowDataOverflow);\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"sources":["/Users/emiliamamedova/charts/flightStats/node_modules/recharts/es6/util/isDomainSpecifiedByUser.js"],"names":["MAX_VALUE_REG","MIN_VALUE_REG","isNumber","isWellBehavedNumber","isWellFormedNumberDomain","v","Array","isArray","length","min","max","extendDomain","providedDomain","boundaryDomain","allowDataOverflow","Math","numericalDomainSpecifiedWithoutRequiringData","userDomain","undefined","providedMin","providedMax","finalMin","finalMax","candidate","parseNumericalUserDomain","dataDomain","result","_unused","_unused2","test","match","exec","value","_unused3","_match","_value"],"mappings":"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","sourcesContent":["import { MAX_VALUE_REG, MIN_VALUE_REG } from './ChartUtils';\nimport { isNumber } from './DataUtils';\nimport { isWellBehavedNumber } from './isWellBehavedNumber';\nexport function isWellFormedNumberDomain(v) {\n  if (Array.isArray(v) && v.length === 2) {\n    var [min, max] = v;\n    if (isWellBehavedNumber(min) && isWellBehavedNumber(max)) {\n      return true;\n    }\n  }\n  return false;\n}\nexport function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {\n  if (allowDataOverflow) {\n    // If the data are allowed to overflow - we're fine with whatever user provided\n    return providedDomain;\n  }\n  /*\n   * If the data are not allowed to overflow - we need to extend the domain.\n   * Means that effectively the user is allowed to make the domain larger\n   * but not smaller.\n   */\n  return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n *\n * This function does not accept data as an argument.\n * This is to enable a performance optimization - if the domain is there,\n * and we know what it is without traversing all the data,\n * then we don't have to traverse all the data!\n *\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param allowDataOverflow boolean, provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {\n  if (!allowDataOverflow) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function') {\n    // The user function expects the data to be provided as an argument\n    return undefined;\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (isWellBehavedNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    if (isWellBehavedNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      // The user function expects the data to be provided as an argument\n      return undefined;\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      return candidate;\n    }\n  }\n  return undefined;\n}\n\n/**\n * So Recharts allows users to provide their own domains,\n * but it also places some expectations on what the domain is.\n * We can improve on the typescript typing, but we also need a runtime test\n * to observe that the user-provided domain is well-formed,\n * that is: an array with exactly two numbers.\n * If the user-provided domain is not well-formed,\n * this function will return undefined - in which case we should traverse the data to calculate the real domain.\n *\n * This function is for parsing the numerical domain only.\n *\n * You are probably thinking, why does domain need tick count?\n * Well it adjusts the domain based on where the \"nice ticks\" land, and nice ticks depend on the tick count.\n *\n * @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.\n * @param dataDomain calculated from data. Can be undefined, as an option for performance optimization\n * @param allowDataOverflow provided by users. If true then the data domain wins\n *\n * @return [min, max] domain if it's well-formed; undefined if the domain is invalid\n */\nexport function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {\n  if (!allowDataOverflow && dataDomain == null) {\n    // Cannot compute data overflow if the data is not provided\n    return undefined;\n  }\n  if (typeof userDomain === 'function' && dataDomain != null) {\n    try {\n      var result = userDomain(dataDomain, allowDataOverflow);\n      if (isWellFormedNumberDomain(result)) {\n        return extendDomain(result, dataDomain, allowDataOverflow);\n      }\n    } catch (_unused) {\n      /* ignore the exception and compute domain from data later */\n    }\n  }\n  if (Array.isArray(userDomain) && userDomain.length === 2) {\n    var [providedMin, providedMax] = userDomain;\n    var finalMin, finalMax;\n    if (providedMin === 'auto') {\n      if (dataDomain != null) {\n        finalMin = Math.min(...dataDomain);\n      }\n    } else if (isNumber(providedMin)) {\n      finalMin = providedMin;\n    } else if (typeof providedMin === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);\n        }\n      } catch (_unused2) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMin === 'string' && MIN_VALUE_REG.test(providedMin)) {\n      var match = MIN_VALUE_REG.exec(providedMin);\n      if (match == null || dataDomain == null) {\n        finalMin = undefined;\n      } else {\n        var value = +match[1];\n        finalMin = dataDomain[0] - value;\n      }\n    } else {\n      finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];\n    }\n    if (providedMax === 'auto') {\n      if (dataDomain != null) {\n        finalMax = Math.max(...dataDomain);\n      }\n    } else if (isNumber(providedMax)) {\n      finalMax = providedMax;\n    } else if (typeof providedMax === 'function') {\n      try {\n        if (dataDomain != null) {\n          finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);\n        }\n      } catch (_unused3) {\n        /* ignore the exception and compute domain from data later */\n      }\n    } else if (typeof providedMax === 'string' && MAX_VALUE_REG.test(providedMax)) {\n      var _match = MAX_VALUE_REG.exec(providedMax);\n      if (_match == null || dataDomain == null) {\n        finalMax = undefined;\n      } else {\n        var _value = +_match[1];\n        finalMax = dataDomain[1] + _value;\n      }\n    } else {\n      finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];\n    }\n    var candidate = [finalMin, finalMax];\n    if (isWellFormedNumberDomain(candidate)) {\n      if (dataDomain == null) {\n        return candidate;\n      }\n      return extendDomain(candidate, dataDomain, allowDataOverflow);\n    }\n  }\n  return undefined;\n}"]},"metadata":{},"sourceType":"module"}