{"ast":null,"code":"function ownKeys(e, r) {\n  var t = Object.keys(e);\n\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n\n  return t;\n}\n\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n\n  return e;\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (\"string\" === r ? String : Number)(t);\n}\n\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { checkDomainOfScale, getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNumber, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nvar defaultNumericDomain = [0, 'auto'];\n/**\n * angle, radius, X, Y, and Z axes all have domain and range and scale and associated settings\n */\n\n/**\n * X and Y axes have ticks. Z axis is never displayed and so it lacks ticks\n * and tick settings.\n */\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\n\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.xAxis[axisId];\n\n  if (axis == null) {\n    return implicitXAxis;\n  }\n\n  return axis;\n};\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\n\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.yAxis[axisId];\n\n  if (axis == null) {\n    return implicitYAxis;\n  }\n\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n\n  if (axis == null) {\n    return implicitZAxis;\n  }\n\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\n\n\nexport var selectAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\n\nexport var selectHasBar = state => state.graphicalItems.countOfBars > 0;\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\n\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n\n      default:\n        return false;\n    }\n  };\n}\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\n\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData);\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\n\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\n\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n\n    case 'yAxis':\n      return errorBar.direction === 'y';\n\n    default:\n      return false;\n  }\n}\n/**\n * This is type of \"error\" in chart. It is set by using ErrorBar, and it can represent confidence interval,\n * or gap in the data, or standard deviation, or quartiles in boxplot, or whiskers or whatever.\n *\n * We will internally represent it as a tuple of two numbers, where the first number is the lower bound and the second number is the upper bound.\n *\n * It is also true that the first number should be lower than or equal to the associated \"main value\",\n * and the second number should be higher than or equal to the associated \"main value\".\n */\n\nexport function fromMainValueToError(value) {\n  if (isNumber(value) && Number.isFinite(value)) {\n    return [value, value];\n  }\n\n  if (Array.isArray(value)) {\n    var minError = Math.min(...value);\n    var maxError = Math.max(...value);\n\n    if (!isNan(minError) && !isNan(maxError) && Number.isFinite(minError) && Number.isFinite(maxError)) {\n      return [minError, maxError];\n    }\n  }\n\n  return undefined;\n}\n\nfunction onlyAllowNumbers(data) {\n  return data.filter(v => isNumOrStr(v) || v instanceof Date).map(Number).filter(n => isNan(n) === false);\n}\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\n\n\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var combineStackGroups = (displayedData, items, stackOffsetType) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n\n    if (acc[item.stackId] == null) {\n      acc[item.stackId] = [];\n    }\n\n    acc[item.stackId].push(item);\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var dataKeys = graphicalItems.map(i => i.dataKey);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems\n    }];\n  }));\n};\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\n\nexport var selectStackGroups = createSelector([selectDisplayedData, selectCartesianItemsSettings, selectStackOffsetType], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n\n  return domainOfStackGroups;\n};\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType], combineDomainOfStackGroups);\nexport var combineAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, axisType) => {\n  if (items.length > 0) {\n    return data.flatMap(entry => {\n      return items.flatMap(item => {\n        var _item$errorBars, _axisSettings$dataKey;\n\n        var relevantErrorBars = (_item$errorBars = item.errorBars) === null || _item$errorBars === void 0 ? void 0 : _item$errorBars.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        return {\n          value: valueByDataKey,\n          errorDomain: getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars)\n        };\n      });\n    }).filter(Boolean);\n  }\n\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey),\n      errorDomain: []\n    }));\n  }\n\n  return data.map(entry => ({\n    value: entry,\n    errorDomain: []\n  }));\n};\nexport var selectAllAppliedNumericalValuesIncludingErrorValues = createSelector(selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, pickAxisType, combineAppliedNumericalValuesIncludingErrorValues);\n\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n\n  return undefined;\n}\n\nvar computeNumericalDomain = dataWithErrorDomains => {\n  var allDataSquished = dataWithErrorDomains // This flatMap has to be flat because we're creating a new array in the return value\n  .flatMap(d => [d.value, d.errorDomain]) // This flat is needed because a) errorDomain is an array, and b) value may be a number, or it may be a range (for Area, for example)\n  .flat(1);\n  var onlyNumbers = onlyAllowNumbers(allDataSquished);\n\n  if (onlyNumbers.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...onlyNumbers), Math.max(...onlyNumbers)];\n};\n\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n\n  return Array.from(new Set(categoricalDomain));\n};\n\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n\n  if (axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n\n  var allDomains = domains.filter(Boolean);\n\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\nexport var combineLinesDomain = (lines, axisType) => {\n  var allCoords = onlyAllowNumbers(lines.map(line => axisType === 'xAxis' ? line.x : line.y));\n\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainOfStackGroups, allDataWithErrorDomains, referenceElementsDomain) => {\n  var domainFromUserPreference = numericalDomainSpecifiedWithoutRequiringData(domainDefinition, axisSettings.allowDataOverflow);\n\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n\n  return parseNumericalUserDomain(domainDefinition, mergeDomains(domainOfStackGroups, referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains)), axisSettings.allowDataOverflow);\n};\nvar selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainOfStackGroups, selectAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain], combineNumericalDomain);\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\n\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if (axisSettings == null || displayedData == null || displayedData.length === 0) {\n    return undefined;\n  }\n\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n\n  if (isCategorical && dataKey == null) {\n    return range(0, displayedData.length);\n  }\n\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\nexport var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n\n  var {\n    scale,\n    type\n  } = axisConfig;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return 'band';\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return 'linear';\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n\n    if (type === 'category') {\n      return 'band';\n    }\n\n    return 'linear';\n  }\n\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return name in d3Scales ? name : 'point';\n  }\n\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);\n\nfunction getD3ScaleFromType(realScaleType) {\n  if (realScaleType == null) {\n    return undefined;\n  }\n\n  if (realScaleType in d3Scales) {\n    // @ts-expect-error we should do better type verification here\n    return d3Scales[realScaleType]();\n  }\n\n  var name = \"scale\".concat(upperFirst(realScaleType));\n\n  if (name in d3Scales) {\n    // @ts-expect-error we should do better type verification here\n    return d3Scales[name]();\n  }\n\n  return undefined;\n}\n\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n\n  if (typeof axis.scale === 'function') {\n    // @ts-expect-error we're going to assume here that if axis.scale is a function then it is a d3Scale function\n    return axis.scale.copy().domain(axisDomain).range(axisRange);\n  }\n\n  var d3ScaleFunction = getD3ScaleFromType(realScaleType);\n\n  if (d3ScaleFunction == null) {\n    return undefined;\n  }\n\n  var scale = d3ScaleFunction.domain(axisDomain).range(axisRange); // I don't like this function because it mutates the scale. We should come up with a way to compute the domain up front.\n\n  checkDomainOfScale(scale);\n  return scale;\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var minFromDomain = domain[0];\n    var minFromTicks = niceTicks[0];\n    var maxFromDomain = domain[1];\n    var maxFromTicks = niceTicks[niceTicks.length - 1];\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\n\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n\n  if (sortedValues.length < 2) {\n    return Infinity;\n  }\n\n  var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];\n\n  if (diff === 0) {\n    return Infinity;\n  } // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n\n\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var distance = sortedValues[i + 1] - sortedValues[i];\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n\n  return selectCalculatedPadding(state, 'xAxis', axisId, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n\n  return selectCalculatedPadding(state, 'yAxis', axisId, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n\n  var {\n    padding\n  } = xAxisSettings;\n\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n\n  var {\n    padding\n  } = yAxisSettings;\n\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector(selectCartesianItemsSettings, pickAxisType, (items, axisType) => {\n  return items.flatMap(item => {\n    var _item$errorBars2;\n\n    return (_item$errorBars2 = item.errorBars) !== null && _item$errorBars2 !== void 0 ? _item$errorBars2 : [];\n  }).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n});\n\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n\n  if (a.id > b.id) {\n    return 1;\n  }\n\n  return 0;\n}\n\nvar pickAxisOrientation = (_state, orientation) => orientation;\n\nvar pickMirror = (_state, _orientation, mirror) => mirror;\n\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\n\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\n\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\n\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\n\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n\n    case 'bottom':\n      return chartHeight - offset.bottom;\n\n    default:\n      return 0;\n  }\n};\n\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n\n    case 'right':\n      return chartWidth - offset.right;\n\n    default:\n      return 0;\n  }\n};\n\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\nexport var selectXAxisPosition = (state, axisId) => {\n  var offset = selectChartOffsetInternal(state);\n  var axisSettings = selectXAxisSettings(state, axisId);\n\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  var allSteps = selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n  var stepOfThisAxis = allSteps[axisId];\n\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n};\nexport var selectYAxisPosition = (state, axisId) => {\n  var offset = selectChartOffsetInternal(state);\n  var axisSettings = selectYAxisSettings(state, axisId);\n\n  if (axisSettings == null) {\n    return undefined;\n  }\n\n  var allSteps = selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n  var stepOfThisAxis = allSteps[axisId];\n\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n};\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return null;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis; // This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n\n  var offsetForBand = realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset; // The ticks set by user should only affect the ticks adjacent to axis line\n\n  var ticksOrNiceTicks = ticks || niceTicks;\n\n  if (ticksOrNiceTicks) {\n    var result = ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        index,\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  } // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n\n  if (scale.ticks) {\n    return scale.ticks(tickCount) // @ts-expect-error why does the offset go here? The type does not require it\n    .map(entry => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset\n    }));\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset; // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n\n  if (scale.ticks) {\n    return scale.ticks(tickCount) // @ts-expect-error why does the offset go here? The type does not require it\n    .map(entry => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset\n    }));\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n\n    default:\n      {\n        return undefined;\n      }\n  }\n});","map":{"version":3,"sources":["/Users/emiliamamedova/charts/project_corona_tracker/node_modules/recharts/es6/state/selectors/axisSelectors.js"],"names":["ownKeys","e","r","t","Object","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","_toPropertyKey","value","configurable","writable","i","_toPrimitive","Symbol","toPrimitive","call","TypeError","String","Number","createSelector","range","d3Scales","selectChartLayout","checkDomainOfScale","getDomainOfStackGroups","getStackedData","getValueByDataKey","isCategoricalAxis","selectChartDataWithIndexes","selectChartDataWithIndexesIfNotInPanorama","isWellFormedNumberDomain","numericalDomainSpecifiedWithoutRequiringData","parseNumericalUserDomain","getPercentValue","hasDuplicate","isNan","isNumber","isNumOrStr","mathSign","upperFirst","isWellBehavedNumber","getNiceTickValues","getTickValuesFixedDomain","selectChartHeight","selectChartWidth","selectAllXAxes","selectAllYAxes","selectChartOffsetInternal","selectBrushDimensions","selectBrushSettings","selectBarCategoryGap","selectChartName","selectStackOffsetType","selectAngleAxis","selectAngleAxisRange","selectRadiusAxis","selectRadiusAxisRange","pickAxisType","pickAxisId","combineAxisRangeWithReverse","DEFAULT_Y_AXIS_WIDTH","defaultNumericDomain","implicitXAxis","allowDataOverflow","allowDecimals","allowDuplicatedCategory","angle","dataKey","undefined","domain","height","hide","id","includeHidden","interval","minTickGap","mirror","name","orientation","padding","left","right","reversed","scale","tick","tickCount","tickFormatter","ticks","type","unit","selectXAxisSettings","state","axisId","axis","cartesianAxis","xAxis","implicitYAxis","top","bottom","width","selectYAxisSettings","yAxis","implicitZAxis","selectZAxisSettings","zAxis","selectBaseAxis","axisType","Error","concat","selectCartesianAxisSettings","selectAxisSettings","selectHasBar","graphicalItems","countOfBars","itemAxisPredicate","item","xAxisId","yAxisId","zAxisId","angleAxisId","radiusAxisId","selectUnfilteredCartesianItems","cartesianItems","selectAxisPredicate","combineGraphicalItemsSettings","axisSettings","axisPredicate","selectCartesianItemsSettings","filterGraphicalNotStackedItems","stackId","selectCartesianItemsSettingsExceptStacked","combineGraphicalItemsData","map","data","Boolean","flat","selectCartesianGraphicalItemsData","combineDisplayedData","graphicalItemsData","_ref","chartData","dataStartIndex","dataEndIndex","slice","selectDisplayedData","combineAppliedValues","items","flatMap","entry","selectAllAppliedValues","isErrorBarRelevantForAxisType","errorBar","direction","fromMainValueToError","isFinite","Array","isArray","minError","Math","min","maxError","max","onlyAllowNumbers","v","Date","n","getErrorDomainByDataKey","appliedValue","relevantErrorBars","eb","errorValue","lowBound","highBound","combineStackGroups","displayedData","stackOffsetType","initialItemsGroups","itemsGroup","reduce","acc","fromEntries","entries","_ref2","dataKeys","stackedData","selectStackGroups","combineDomainOfStackGroups","stackGroups","_ref3","domainOfStackGroups","selectDomainOfStackGroups","combineAppliedNumericalValuesIncludingErrorValues","_item$errorBars","_axisSettings$dataKey","errorBars","valueByDataKey","errorDomain","selectAllAppliedNumericalValuesIncludingErrorValues","onlyAllowNumbersAndStringsAndDates","computeNumericalDomain","dataWithErrorDomains","allDataSquished","d","onlyNumbers","computeDomainOfTypeCategory","isCategorical","categoricalDomain","from","Set","getDomainDefinition","_axisSettings$domain","allValues","mergeDomains","_len","domains","_key","allDomains","selectReferenceDots","referenceElements","dots","filterReferenceElements","elements","el","ifOverflow","selectReferenceDotsByAxis","selectReferenceAreas","areas","selectReferenceAreasByAxis","selectReferenceLines","lines","selectReferenceLinesByAxis","combineDotsDomain","allCoords","dot","x","y","selectReferenceDotsDomain","combineAreasDomain","area","x1","y1","x2","y2","selectReferenceAreasDomain","combineLinesDomain","line","selectReferenceLinesDomain","selectReferenceElementsDomain","dotsDomain","linesDomain","areasDomain","selectDomainDefinition","combineNumericalDomain","domainDefinition","allDataWithErrorDomains","referenceElementsDomain","domainFromUserPreference","selectNumericalDomain","expandDomain","combineAxisDomain","layout","allAppliedValues","numericalDomain","selectAxisDomain","combineRealScaleType","axisConfig","hasBar","chartType","indexOf","selectRealScaleType","getD3ScaleFromType","realScaleType","combineScaleFunction","axisDomain","axisRange","copy","d3ScaleFunction","combineNiceTicks","selectNiceTicks","combineAxisDomainWithNiceTicks","niceTicks","minFromDomain","minFromTicks","maxFromDomain","maxFromTicks","selectAxisDomainIncludingNiceTicks","selectSmallestDistanceBetweenValues","smallestDistanceBetweenValues","Infinity","sortedValues","sort","a","b","diff","distance","selectCalculatedPadding","_1","_2","_3","smallestDistanceInPercent","barCategoryGap","offset","rangeWidth","gap","halfBand","selectCalculatedXAxisPadding","xAxisSettings","selectCalculatedYAxisPadding","yAxisSettings","selectXAxisPadding","calculated","_padding$left","_padding$right","selectYAxisPadding","_padding$top","_padding$bottom","combineXAxisRange","_state","_axisId","isPanorama","brushDimensions","_ref4","brushPadding","combineYAxisRange","_ref5","selectAxisRange","_selectZAxisSettings","selectAxisRangeWithReverse","selectAxisScale","selectErrorBarsSettings","_item$errorBars2","compareIds","pickAxisOrientation","pickMirror","_orientation","selectAllXAxesWithOffsetType","allAxes","selectAllYAxesWithOffsetType","getXAxisSize","getYAxisSize","selectXAxisSize","combineXAxisPositionStartingPoint","chartHeight","combineYAxisPositionStartingPoint","chartWidth","selectAllXAxesOffsetSteps","allAxesWithSameOffsetType","steps","position","axisSize","needSpace","selectAllYAxesOffsetSteps","selectXAxisPosition","allSteps","stepOfThisAxis","selectYAxisPosition","selectYAxisSize","selectCartesianAxisSize","combineDuplicateDomain","chartLayout","appliedValues","allData","av","selectDuplicateDomain","combineCategoricalDomain","selectCategoricalDomain","selectAxisPropsNeededForCartesianGridTicksGenerator","duplicateDomain","combineAxisTicks","offsetForBand","bandwidth","ticksOrNiceTicks","result","index","scaleContent","coordinate","row","selectTicksOfAxis","combineGraphicalItemTicks","selectTicksOfGraphicalItem","selectAxisWithScale","selectZAxisScale","selectZAxisWithScale","_axisType","selectChartDirection","allXAxes","allYAxes","some"],"mappings":"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","sourcesContent":["function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == typeof i ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != typeof i) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nimport { createSelector } from 'reselect';\nimport range from 'es-toolkit/compat/range';\nimport * as d3Scales from 'victory-vendor/d3-scale';\nimport { selectChartLayout } from '../../context/chartLayoutContext';\nimport { checkDomainOfScale, getDomainOfStackGroups, getStackedData, getValueByDataKey, isCategoricalAxis } from '../../util/ChartUtils';\nimport { selectChartDataWithIndexes, selectChartDataWithIndexesIfNotInPanorama } from './dataSelectors';\nimport { isWellFormedNumberDomain, numericalDomainSpecifiedWithoutRequiringData, parseNumericalUserDomain } from '../../util/isDomainSpecifiedByUser';\nimport { getPercentValue, hasDuplicate, isNan, isNumber, isNumOrStr, mathSign, upperFirst } from '../../util/DataUtils';\nimport { isWellBehavedNumber } from '../../util/isWellBehavedNumber';\nimport { getNiceTickValues, getTickValuesFixedDomain } from '../../util/scale';\nimport { selectChartHeight, selectChartWidth } from './containerSelectors';\nimport { selectAllXAxes, selectAllYAxes } from './selectAllAxes';\nimport { selectChartOffsetInternal } from './selectChartOffsetInternal';\nimport { selectBrushDimensions, selectBrushSettings } from './brushSelectors';\nimport { selectBarCategoryGap, selectChartName, selectStackOffsetType } from './rootPropsSelectors';\nimport { selectAngleAxis, selectAngleAxisRange, selectRadiusAxis, selectRadiusAxisRange } from './polarAxisSelectors';\nimport { pickAxisType } from './pickAxisType';\nimport { pickAxisId } from './pickAxisId';\nimport { combineAxisRangeWithReverse } from './combiners/combineAxisRangeWithReverse';\nimport { DEFAULT_Y_AXIS_WIDTH } from '../../util/Constants';\nvar defaultNumericDomain = [0, 'auto'];\n\n/**\n * angle, radius, X, Y, and Z axes all have domain and range and scale and associated settings\n */\n\n/**\n * X and Y axes have ticks. Z axis is never displayed and so it lacks ticks\n * and tick settings.\n */\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitXAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: undefined,\n  height: 30,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'bottom',\n  padding: {\n    left: 0,\n    right: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'category',\n  unit: undefined\n};\nexport var selectXAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.xAxis[axisId];\n  if (axis == null) {\n    return implicitXAxis;\n  }\n  return axis;\n};\n\n/**\n * If an axis is not explicitly defined as an element,\n * we still need to render something in the chart and we need\n * some object to hold the domain and default settings.\n */\nexport var implicitYAxis = {\n  allowDataOverflow: false,\n  allowDecimals: true,\n  allowDuplicatedCategory: true,\n  angle: 0,\n  dataKey: undefined,\n  domain: defaultNumericDomain,\n  hide: true,\n  id: 0,\n  includeHidden: false,\n  interval: 'preserveEnd',\n  minTickGap: 5,\n  mirror: false,\n  name: undefined,\n  orientation: 'left',\n  padding: {\n    top: 0,\n    bottom: 0\n  },\n  reversed: false,\n  scale: 'auto',\n  tick: true,\n  tickCount: 5,\n  tickFormatter: undefined,\n  ticks: undefined,\n  type: 'number',\n  unit: undefined,\n  width: DEFAULT_Y_AXIS_WIDTH\n};\nexport var selectYAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.yAxis[axisId];\n  if (axis == null) {\n    return implicitYAxis;\n  }\n  return axis;\n};\nexport var implicitZAxis = {\n  domain: [0, 'auto'],\n  includeHidden: false,\n  reversed: false,\n  allowDataOverflow: false,\n  allowDuplicatedCategory: false,\n  dataKey: undefined,\n  id: 0,\n  name: '',\n  range: [64, 64],\n  scale: 'auto',\n  type: 'number',\n  unit: ''\n};\nexport var selectZAxisSettings = (state, axisId) => {\n  var axis = state.cartesianAxis.zAxis[axisId];\n  if (axis == null) {\n    return implicitZAxis;\n  }\n  return axis;\n};\nexport var selectBaseAxis = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'zAxis':\n      {\n        return selectZAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\nvar selectCartesianAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.\n * @param state Root state\n * @param axisType xAxis | yAxis\n * @param axisId xAxisId | yAxisId\n * @returns axis settings object\n */\nexport var selectAxisSettings = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSettings(state, axisId);\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSettings(state, axisId);\n      }\n    case 'angleAxis':\n      {\n        return selectAngleAxis(state, axisId);\n      }\n    case 'radiusAxis':\n      {\n        return selectRadiusAxis(state, axisId);\n      }\n    default:\n      throw new Error(\"Unexpected axis type: \".concat(axisType));\n  }\n};\n\n/**\n * @param state RechartsRootState\n * @return boolean true if there is at least one Bar or RadialBar\n */\nexport var selectHasBar = state => state.graphicalItems.countOfBars > 0;\n\n/**\n * Filters CartesianGraphicalItemSettings by the relevant axis ID\n * @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'\n * @param axisId from props, defaults to 0\n *\n * @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis\n */\nexport function itemAxisPredicate(axisType, axisId) {\n  return item => {\n    switch (axisType) {\n      case 'xAxis':\n        // This is sensitive to the data type, as 0 !== '0'. I wonder if we should be more flexible. How does 2.x branch behave? TODO write test for that\n        return 'xAxisId' in item && item.xAxisId === axisId;\n      case 'yAxis':\n        return 'yAxisId' in item && item.yAxisId === axisId;\n      case 'zAxis':\n        return 'zAxisId' in item && item.zAxisId === axisId;\n      case 'angleAxis':\n        return 'angleAxisId' in item && item.angleAxisId === axisId;\n      case 'radiusAxis':\n        return 'radiusAxisId' in item && item.radiusAxisId === axisId;\n      default:\n        return false;\n    }\n  };\n}\nexport var selectUnfilteredCartesianItems = state => state.graphicalItems.cartesianItems;\nvar selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);\nexport var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter(item => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) {\n    return true;\n  }\n  return !item.hide;\n});\nexport var selectCartesianItemsSettings = createSelector([selectUnfilteredCartesianItems, selectBaseAxis, selectAxisPredicate], combineGraphicalItemsSettings);\nexport var filterGraphicalNotStackedItems = cartesianItems => cartesianItems.filter(item => item.stackId === undefined);\nvar selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);\nexport var combineGraphicalItemsData = cartesianItems => cartesianItems.map(item => item.data).filter(Boolean).flat(1);\n\n/**\n * This is a \"cheap\" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.\n * Also does not apply dataKey yet.\n * @param state RechartsRootState\n * @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey\n */\nexport var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData);\nexport var combineDisplayedData = (graphicalItemsData, _ref) => {\n  var {\n    chartData = [],\n    dataStartIndex,\n    dataEndIndex\n  } = _ref;\n  if (graphicalItemsData.length > 0) {\n    /*\n     * There is no slicing when data is defined on graphical items. Why?\n     * Because Brush ignores data defined on graphical items,\n     * and does not render.\n     * So Brush will never show up in a Scatter chart for example.\n     * This is something we will need to fix.\n     *\n     * Now, when the root chart data is not defined, the dataEndIndex is 0,\n     * which means the itemsData will be sliced to an empty array anyway.\n     * But that's an implementation detail, and we can fix that too.\n     *\n     * Also, in absence of Axis dataKey, we use the dataKey from each item, respectively.\n     * This is the usual pattern for numerical axis, that is the one where bars go up:\n     * users don't specify any dataKey by default and expect the axis to \"just match the data\".\n     */\n    return graphicalItemsData;\n  }\n  return chartData.slice(dataStartIndex, dataEndIndex + 1);\n};\n\n/**\n * This selector will return all data there is in the chart: graphical items, chart root, all together.\n * Useful for figuring out an axis domain (because that needs to know of everything),\n * not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).\n *\n * This function will discard the original indexes, so it is also not useful for anything that depends on ordering.\n */\nexport var selectDisplayedData = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);\nexport var combineAppliedValues = (data, axisSettings, items) => {\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey)\n    }));\n  }\n  if (items.length > 0) {\n    return items.map(item => item.dataKey).flatMap(dataKey => data.map(entry => ({\n      value: getValueByDataKey(entry, dataKey)\n    })));\n  }\n  return data.map(entry => ({\n    value: entry\n  }));\n};\n\n/**\n * This selector will return all values with the appropriate dataKey applied on them.\n * Which dataKey is appropriate depends on where it is defined.\n *\n * This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.\n */\nexport var selectAllAppliedValues = createSelector([selectDisplayedData, selectBaseAxis, selectCartesianItemsSettings], combineAppliedValues);\nexport function isErrorBarRelevantForAxisType(axisType, errorBar) {\n  switch (axisType) {\n    case 'xAxis':\n      return errorBar.direction === 'x';\n    case 'yAxis':\n      return errorBar.direction === 'y';\n    default:\n      return false;\n  }\n}\n\n/**\n * This is type of \"error\" in chart. It is set by using ErrorBar, and it can represent confidence interval,\n * or gap in the data, or standard deviation, or quartiles in boxplot, or whiskers or whatever.\n *\n * We will internally represent it as a tuple of two numbers, where the first number is the lower bound and the second number is the upper bound.\n *\n * It is also true that the first number should be lower than or equal to the associated \"main value\",\n * and the second number should be higher than or equal to the associated \"main value\".\n */\n\nexport function fromMainValueToError(value) {\n  if (isNumber(value) && Number.isFinite(value)) {\n    return [value, value];\n  }\n  if (Array.isArray(value)) {\n    var minError = Math.min(...value);\n    var maxError = Math.max(...value);\n    if (!isNan(minError) && !isNan(maxError) && Number.isFinite(minError) && Number.isFinite(maxError)) {\n      return [minError, maxError];\n    }\n  }\n  return undefined;\n}\nfunction onlyAllowNumbers(data) {\n  return data.filter(v => isNumOrStr(v) || v instanceof Date).map(Number).filter(n => isNan(n) === false);\n}\n\n/**\n * @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application\n * @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.\n * @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.\n * @return either undefined or an array of ErrorValue\n */\nexport function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {\n  if (!relevantErrorBars || typeof appliedValue !== 'number' || isNan(appliedValue)) {\n    return [];\n  }\n  if (!relevantErrorBars.length) {\n    return [];\n  }\n  return onlyAllowNumbers(relevantErrorBars.flatMap(eb => {\n    var errorValue = getValueByDataKey(entry, eb.dataKey);\n    var lowBound, highBound;\n    if (Array.isArray(errorValue)) {\n      [lowBound, highBound] = errorValue;\n    } else {\n      lowBound = highBound = errorValue;\n    }\n    if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) {\n      return undefined;\n    }\n    return [appliedValue - lowBound, appliedValue + highBound];\n  }));\n}\nexport var combineStackGroups = (displayedData, items, stackOffsetType) => {\n  var initialItemsGroups = {};\n  var itemsGroup = items.reduce((acc, item) => {\n    if (item.stackId == null) {\n      return acc;\n    }\n    if (acc[item.stackId] == null) {\n      acc[item.stackId] = [];\n    }\n    acc[item.stackId].push(item);\n    return acc;\n  }, initialItemsGroups);\n  return Object.fromEntries(Object.entries(itemsGroup).map(_ref2 => {\n    var [stackId, graphicalItems] = _ref2;\n    var dataKeys = graphicalItems.map(i => i.dataKey);\n    return [stackId, {\n      // @ts-expect-error getStackedData requires that the input is array of objects, Recharts does not test for that\n      stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),\n      graphicalItems\n    }];\n  }));\n};\n/**\n * Stack groups are groups of graphical items that stack on each other.\n * Stack is a function of axis type (X, Y), axis ID, and stack ID.\n * Graphical items that do not have a stack ID are not going to be present in stack groups.\n */\nexport var selectStackGroups = createSelector([selectDisplayedData, selectCartesianItemsSettings, selectStackOffsetType], combineStackGroups);\nexport var combineDomainOfStackGroups = (stackGroups, _ref3, axisType) => {\n  var {\n    dataStartIndex,\n    dataEndIndex\n  } = _ref3;\n  if (axisType === 'zAxis') {\n    // ZAxis ignores stacks\n    return undefined;\n  }\n  var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);\n  if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) {\n    return undefined;\n  }\n  return domainOfStackGroups;\n};\nexport var selectDomainOfStackGroups = createSelector([selectStackGroups, selectChartDataWithIndexes, pickAxisType], combineDomainOfStackGroups);\nexport var combineAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, axisType) => {\n  if (items.length > 0) {\n    return data.flatMap(entry => {\n      return items.flatMap(item => {\n        var _item$errorBars, _axisSettings$dataKey;\n        var relevantErrorBars = (_item$errorBars = item.errorBars) === null || _item$errorBars === void 0 ? void 0 : _item$errorBars.filter(errorBar => isErrorBarRelevantForAxisType(axisType, errorBar));\n        var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);\n        return {\n          value: valueByDataKey,\n          errorDomain: getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars)\n        };\n      });\n    }).filter(Boolean);\n  }\n  if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) {\n    return data.map(item => ({\n      value: getValueByDataKey(item, axisSettings.dataKey),\n      errorDomain: []\n    }));\n  }\n  return data.map(entry => ({\n    value: entry,\n    errorDomain: []\n  }));\n};\nexport var selectAllAppliedNumericalValuesIncludingErrorValues = createSelector(selectDisplayedData, selectBaseAxis, selectCartesianItemsSettingsExceptStacked, pickAxisType, combineAppliedNumericalValuesIncludingErrorValues);\nfunction onlyAllowNumbersAndStringsAndDates(item) {\n  var {\n    value\n  } = item;\n  if (isNumOrStr(value) || value instanceof Date) {\n    return value;\n  }\n  return undefined;\n}\nvar computeNumericalDomain = dataWithErrorDomains => {\n  var allDataSquished = dataWithErrorDomains\n  // This flatMap has to be flat because we're creating a new array in the return value\n  .flatMap(d => [d.value, d.errorDomain])\n  // This flat is needed because a) errorDomain is an array, and b) value may be a number, or it may be a range (for Area, for example)\n  .flat(1);\n  var onlyNumbers = onlyAllowNumbers(allDataSquished);\n  if (onlyNumbers.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...onlyNumbers), Math.max(...onlyNumbers)];\n};\nvar computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {\n  var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter(v => v != null);\n  if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) {\n    /*\n     * 1. In an absence of dataKey, Recharts will use array indexes as its categorical domain\n     * 2. When category axis has duplicated text, serial numbers are used to generate scale\n     */\n    return range(0, allDataSquished.length);\n  }\n  if (axisSettings.allowDuplicatedCategory) {\n    return categoricalDomain;\n  }\n  return Array.from(new Set(categoricalDomain));\n};\nexport var getDomainDefinition = axisSettings => {\n  var _axisSettings$domain;\n  if (axisSettings == null || !('domain' in axisSettings)) {\n    return defaultNumericDomain;\n  }\n  if (axisSettings.domain != null) {\n    return axisSettings.domain;\n  }\n  if (axisSettings.ticks != null) {\n    if (axisSettings.type === 'number') {\n      var allValues = onlyAllowNumbers(axisSettings.ticks);\n      return [Math.min(...allValues), Math.max(...allValues)];\n    }\n    if (axisSettings.type === 'category') {\n      return axisSettings.ticks.map(String);\n    }\n  }\n  return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;\n};\nexport var mergeDomains = function mergeDomains() {\n  for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) {\n    domains[_key] = arguments[_key];\n  }\n  var allDomains = domains.filter(Boolean);\n  if (allDomains.length === 0) {\n    return undefined;\n  }\n  var allValues = allDomains.flat();\n  var min = Math.min(...allValues);\n  var max = Math.max(...allValues);\n  return [min, max];\n};\nexport var selectReferenceDots = state => state.referenceElements.dots;\nexport var filterReferenceElements = (elements, axisType, axisId) => {\n  return elements.filter(el => el.ifOverflow === 'extendDomain').filter(el => {\n    if (axisType === 'xAxis') {\n      return el.xAxisId === axisId;\n    }\n    return el.yAxisId === axisId;\n  });\n};\nexport var selectReferenceDotsByAxis = createSelector([selectReferenceDots, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceAreas = state => state.referenceElements.areas;\nexport var selectReferenceAreasByAxis = createSelector([selectReferenceAreas, pickAxisType, pickAxisId], filterReferenceElements);\nexport var selectReferenceLines = state => state.referenceElements.lines;\nexport var selectReferenceLinesByAxis = createSelector([selectReferenceLines, pickAxisType, pickAxisId], filterReferenceElements);\nexport var combineDotsDomain = (dots, axisType) => {\n  var allCoords = onlyAllowNumbers(dots.map(dot => axisType === 'xAxis' ? dot.x : dot.y));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);\nexport var combineAreasDomain = (areas, axisType) => {\n  var allCoords = onlyAllowNumbers(areas.flatMap(area => [axisType === 'xAxis' ? area.x1 : area.y1, axisType === 'xAxis' ? area.x2 : area.y2]));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);\nexport var combineLinesDomain = (lines, axisType) => {\n  var allCoords = onlyAllowNumbers(lines.map(line => axisType === 'xAxis' ? line.x : line.y));\n  if (allCoords.length === 0) {\n    return undefined;\n  }\n  return [Math.min(...allCoords), Math.max(...allCoords)];\n};\nvar selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);\nvar selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {\n  return mergeDomains(dotsDomain, areasDomain, linesDomain);\n});\nexport var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);\nexport var combineNumericalDomain = (axisSettings, domainDefinition, domainOfStackGroups, allDataWithErrorDomains, referenceElementsDomain) => {\n  var domainFromUserPreference = numericalDomainSpecifiedWithoutRequiringData(domainDefinition, axisSettings.allowDataOverflow);\n  if (domainFromUserPreference != null) {\n    // We're done! No need to compute anything else.\n    return domainFromUserPreference;\n  }\n  return parseNumericalUserDomain(domainDefinition, mergeDomains(domainOfStackGroups, referenceElementsDomain, computeNumericalDomain(allDataWithErrorDomains)), axisSettings.allowDataOverflow);\n};\nvar selectNumericalDomain = createSelector([selectBaseAxis, selectDomainDefinition, selectDomainOfStackGroups, selectAllAppliedNumericalValuesIncludingErrorValues, selectReferenceElementsDomain], combineNumericalDomain);\n\n/**\n * Expand by design maps everything between 0 and 1,\n * there is nothing to compute.\n * See https://d3js.org/d3-shape/stack#stack-offsets\n */\nvar expandDomain = [0, 1];\nexport var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {\n  if (axisSettings == null || displayedData == null || displayedData.length === 0) {\n    return undefined;\n  }\n  var {\n    dataKey,\n    type\n  } = axisSettings;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && dataKey == null) {\n    return range(0, displayedData.length);\n  }\n  if (type === 'category') {\n    return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);\n  }\n  if (stackOffsetType === 'expand') {\n    return expandDomain;\n  }\n  return numericalDomain;\n};\nexport var selectAxisDomain = createSelector([selectBaseAxis, selectChartLayout, selectDisplayedData, selectAllAppliedValues, selectStackOffsetType, pickAxisType, selectNumericalDomain], combineAxisDomain);\nexport var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {\n  if (axisConfig == null) {\n    return undefined;\n  }\n  var {\n    scale,\n    type\n  } = axisConfig;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return 'band';\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return 'linear';\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0 || chartType.indexOf('ComposedChart') >= 0 && !hasBar)) {\n      return 'point';\n    }\n    if (type === 'category') {\n      return 'band';\n    }\n    return 'linear';\n  }\n  if (typeof scale === 'string') {\n    var name = \"scale\".concat(upperFirst(scale));\n    return name in d3Scales ? name : 'point';\n  }\n  return undefined;\n};\nexport var selectRealScaleType = createSelector([selectBaseAxis, selectChartLayout, selectHasBar, selectChartName, pickAxisType], combineRealScaleType);\nfunction getD3ScaleFromType(realScaleType) {\n  if (realScaleType == null) {\n    return undefined;\n  }\n  if (realScaleType in d3Scales) {\n    // @ts-expect-error we should do better type verification here\n    return d3Scales[realScaleType]();\n  }\n  var name = \"scale\".concat(upperFirst(realScaleType));\n  if (name in d3Scales) {\n    // @ts-expect-error we should do better type verification here\n    return d3Scales[name]();\n  }\n  return undefined;\n}\nexport function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {\n  if (axisDomain == null || axisRange == null) {\n    return undefined;\n  }\n  if (typeof axis.scale === 'function') {\n    // @ts-expect-error we're going to assume here that if axis.scale is a function then it is a d3Scale function\n    return axis.scale.copy().domain(axisDomain).range(axisRange);\n  }\n  var d3ScaleFunction = getD3ScaleFromType(realScaleType);\n  if (d3ScaleFunction == null) {\n    return undefined;\n  }\n  var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);\n  // I don't like this function because it mutates the scale. We should come up with a way to compute the domain up front.\n  checkDomainOfScale(scale);\n  return scale;\n}\nexport var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {\n  var domainDefinition = getDomainDefinition(axisSettings);\n  if (realScaleType !== 'auto' && realScaleType !== 'linear') {\n    return undefined;\n  }\n  if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === 'auto' || domainDefinition[1] === 'auto') && isWellFormedNumberDomain(axisDomain)) {\n    return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  if (axisSettings != null && axisSettings.tickCount && axisSettings.type === 'number' && isWellFormedNumberDomain(axisDomain)) {\n    return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);\n  }\n  return undefined;\n};\nexport var selectNiceTicks = createSelector([selectAxisDomain, selectAxisSettings, selectRealScaleType], combineNiceTicks);\nexport var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {\n  if (\n  /*\n   * Angle axis for some reason uses nice ticks when rendering axis tick labels,\n   * but doesn't use nice ticks for extending domain like all the other axes do.\n   * Not really sure why? Is there a good reason,\n   * or is it just because someone added support for nice ticks to the other axes and forgot this one?\n   */\n  axisType !== 'angleAxis' && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === 'number' && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {\n    var minFromDomain = domain[0];\n    var minFromTicks = niceTicks[0];\n    var maxFromDomain = domain[1];\n    var maxFromTicks = niceTicks[niceTicks.length - 1];\n    return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];\n  }\n  return domain;\n};\nexport var selectAxisDomainIncludingNiceTicks = createSelector([selectBaseAxis, selectAxisDomain, selectNiceTicks, pickAxisType], combineAxisDomainWithNiceTicks);\n\n/**\n * Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).\n * Ignores domain provided by user and only considers domain from data.\n *\n * The result is a number between 0 and 1.\n */\nexport var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {\n  if (!axisSettings || axisSettings.type !== 'number') {\n    return undefined;\n  }\n  var smallestDistanceBetweenValues = Infinity;\n  var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map(d => d.value))).sort((a, b) => a - b);\n  if (sortedValues.length < 2) {\n    return Infinity;\n  }\n  var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];\n  if (diff === 0) {\n    return Infinity;\n  }\n  // Only do n - 1 distance calculations because there's only n - 1 distances between n values.\n  for (var i = 0; i < sortedValues.length - 1; i++) {\n    var distance = sortedValues[i + 1] - sortedValues[i];\n    smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);\n  }\n  return smallestDistanceBetweenValues / diff;\n});\nvar selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {\n  if (!isWellBehavedNumber(smallestDistanceInPercent)) {\n    return 0;\n  }\n  var rangeWidth = layout === 'vertical' ? offset.height : offset.width;\n  if (padding === 'gap') {\n    return smallestDistanceInPercent * rangeWidth / 2;\n  }\n  if (padding === 'no-gap') {\n    var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);\n    var halfBand = smallestDistanceInPercent * rangeWidth / 2;\n    return halfBand - gap - (halfBand - gap) / rangeWidth * gap;\n  }\n  return 0;\n});\nexport var selectCalculatedXAxisPadding = (state, axisId) => {\n  var xAxisSettings = selectXAxisSettings(state, axisId);\n  if (xAxisSettings == null || typeof xAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'xAxis', axisId, xAxisSettings.padding);\n};\nexport var selectCalculatedYAxisPadding = (state, axisId) => {\n  var yAxisSettings = selectYAxisSettings(state, axisId);\n  if (yAxisSettings == null || typeof yAxisSettings.padding !== 'string') {\n    return 0;\n  }\n  return selectCalculatedPadding(state, 'yAxis', axisId, yAxisSettings.padding);\n};\nvar selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {\n  var _padding$left, _padding$right;\n  if (xAxisSettings == null) {\n    return {\n      left: 0,\n      right: 0\n    };\n  }\n  var {\n    padding\n  } = xAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      left: calculated,\n      right: calculated\n    };\n  }\n  return {\n    left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,\n    right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated\n  };\n});\nvar selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {\n  var _padding$top, _padding$bottom;\n  if (yAxisSettings == null) {\n    return {\n      top: 0,\n      bottom: 0\n    };\n  }\n  var {\n    padding\n  } = yAxisSettings;\n  if (typeof padding === 'string') {\n    return {\n      top: calculated,\n      bottom: calculated\n    };\n  }\n  return {\n    top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,\n    bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated\n  };\n});\nexport var combineXAxisRange = createSelector([selectChartOffsetInternal, selectXAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, padding, brushDimensions, _ref4, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref4;\n  if (isPanorama) {\n    return [brushPadding.left, brushDimensions.width - brushPadding.right];\n  }\n  return [offset.left + padding.left, offset.left + offset.width - padding.right];\n});\nexport var combineYAxisRange = createSelector([selectChartOffsetInternal, selectChartLayout, selectYAxisPadding, selectBrushDimensions, selectBrushSettings, (_state, _axisId, isPanorama) => isPanorama], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {\n  var {\n    padding: brushPadding\n  } = _ref5;\n  if (isPanorama) {\n    return [brushDimensions.height - brushPadding.bottom, brushPadding.top];\n  }\n  if (layout === 'horizontal') {\n    return [offset.top + offset.height - padding.bottom, offset.top + padding.top];\n  }\n  return [offset.top + padding.top, offset.top + offset.height - padding.bottom];\n});\nexport var selectAxisRange = (state, axisType, axisId, isPanorama) => {\n  var _selectZAxisSettings;\n  switch (axisType) {\n    case 'xAxis':\n      return combineXAxisRange(state, axisId, isPanorama);\n    case 'yAxis':\n      return combineYAxisRange(state, axisId, isPanorama);\n    case 'zAxis':\n      return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;\n    case 'angleAxis':\n      return selectAngleAxisRange(state);\n    case 'radiusAxis':\n      return selectRadiusAxisRange(state, axisId);\n    default:\n      return undefined;\n  }\n};\nexport var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);\nexport var selectAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomainIncludingNiceTicks, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectErrorBarsSettings = createSelector(selectCartesianItemsSettings, pickAxisType, (items, axisType) => {\n  return items.flatMap(item => {\n    var _item$errorBars2;\n    return (_item$errorBars2 = item.errorBars) !== null && _item$errorBars2 !== void 0 ? _item$errorBars2 : [];\n  }).filter(e => {\n    return isErrorBarRelevantForAxisType(axisType, e);\n  });\n});\nfunction compareIds(a, b) {\n  if (a.id < b.id) {\n    return -1;\n  }\n  if (a.id > b.id) {\n    return 1;\n  }\n  return 0;\n}\nvar pickAxisOrientation = (_state, orientation) => orientation;\nvar pickMirror = (_state, _orientation, mirror) => mirror;\nvar selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter(axis => axis.orientation === orientation).filter(axis => axis.mirror === mirror).sort(compareIds));\nvar getXAxisSize = (offset, axisSettings) => {\n  return {\n    width: offset.width,\n    height: axisSettings.height\n  };\n};\nvar getYAxisSize = (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n};\nexport var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);\nvar combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {\n  switch (orientation) {\n    case 'top':\n      return offset.top;\n    case 'bottom':\n      return chartHeight - offset.bottom;\n    default:\n      return 0;\n  }\n};\nvar combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {\n  switch (orientation) {\n    case 'left':\n      return offset.left;\n    case 'right':\n      return chartWidth - offset.right;\n    default:\n      return 0;\n  }\n};\nexport var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getXAxisSize(offset, axis);\n    if (position == null) {\n      position = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);\n    }\n    var needSpace = orientation === 'top' && !mirror || orientation === 'bottom' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.height;\n    position += (needSpace ? -1 : 1) * axisSize.height;\n  });\n  return steps;\n});\nexport var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {\n  var steps = {};\n  var position;\n  allAxesWithSameOffsetType.forEach(axis => {\n    var axisSize = getYAxisSize(offset, axis);\n    if (position == null) {\n      position = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);\n    }\n    var needSpace = orientation === 'left' && !mirror || orientation === 'right' && mirror;\n    steps[axis.id] = position - Number(needSpace) * axisSize.width;\n    position += (needSpace ? -1 : 1) * axisSize.width;\n  });\n  return steps;\n});\nexport var selectXAxisPosition = (state, axisId) => {\n  var offset = selectChartOffsetInternal(state);\n  var axisSettings = selectXAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var allSteps = selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n  var stepOfThisAxis = allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: offset.left,\n      y: 0\n    };\n  }\n  return {\n    x: offset.left,\n    y: stepOfThisAxis\n  };\n};\nexport var selectYAxisPosition = (state, axisId) => {\n  var offset = selectChartOffsetInternal(state);\n  var axisSettings = selectYAxisSettings(state, axisId);\n  if (axisSettings == null) {\n    return undefined;\n  }\n  var allSteps = selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);\n  var stepOfThisAxis = allSteps[axisId];\n  if (stepOfThisAxis == null) {\n    return {\n      x: 0,\n      y: offset.top\n    };\n  }\n  return {\n    x: stepOfThisAxis,\n    y: offset.top\n  };\n};\nexport var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {\n  var width = typeof axisSettings.width === 'number' ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH;\n  return {\n    width,\n    height: offset.height\n  };\n});\nexport var selectCartesianAxisSize = (state, axisType, axisId) => {\n  switch (axisType) {\n    case 'xAxis':\n      {\n        return selectXAxisSize(state, axisId).width;\n      }\n    case 'yAxis':\n      {\n        return selectYAxisSize(state, axisId).height;\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n};\nexport var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {\n  if (axis == null) {\n    return undefined;\n  }\n  var {\n    allowDuplicatedCategory,\n    type,\n    dataKey\n  } = axis;\n  var isCategorical = isCategoricalAxis(chartLayout, axisType);\n  var allData = appliedValues.map(av => av.value);\n  if (dataKey && isCategorical && type === 'category' && allowDuplicatedCategory && hasDuplicate(allData)) {\n    return allData;\n  }\n  return undefined;\n};\nexport var selectDuplicateDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectBaseAxis, pickAxisType], combineDuplicateDomain);\nexport var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {\n  if (axis == null || axis.dataKey == null) {\n    return undefined;\n  }\n  var {\n    type,\n    scale\n  } = axis;\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  if (isCategorical && (type === 'number' || scale !== 'auto')) {\n    return appliedValues.map(d => d.value);\n  }\n  return undefined;\n};\nexport var selectCategoricalDomain = createSelector([selectChartLayout, selectAllAppliedValues, selectAxisSettings, pickAxisType], combineCategoricalDomain);\nexport var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([selectChartLayout, selectCartesianAxisSettings, selectRealScaleType, selectAxisScale, selectDuplicateDomain, selectCategoricalDomain, selectAxisRange, selectNiceTicks, pickAxisType], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {\n  if (axis == null) {\n    return null;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  return {\n    angle: axis.angle,\n    interval: axis.interval,\n    minTickGap: axis.minTickGap,\n    orientation: axis.orientation,\n    tick: axis.tick,\n    tickCount: axis.tickCount,\n    tickFormatter: axis.tickFormatter,\n    ticks: axis.ticks,\n    type: axis.type,\n    unit: axis.unit,\n    axisType,\n    categoricalDomain,\n    duplicateDomain,\n    isCategorical,\n    niceTicks,\n    range: axisRange,\n    realScaleType,\n    scale\n  };\n});\nexport var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    type,\n    ticks,\n    tickCount\n  } = axis;\n\n  // This is testing for `scaleBand` but for band axis the type is reported as `band` so this looks like a dead code with a workaround elsewhere?\n  var offsetForBand = realScaleType === 'scaleBand' && typeof scale.bandwidth === 'function' ? scale.bandwidth() / 2 : 2;\n  var offset = type === 'category' && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;\n  offset = axisType === 'angleAxis' && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // The ticks set by user should only affect the ticks adjacent to axis line\n  var ticksOrNiceTicks = ticks || niceTicks;\n  if (ticksOrNiceTicks) {\n    var result = ticksOrNiceTicks.map((entry, index) => {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        index,\n        // If the scaleContent is not a number, the coordinate will be NaN.\n        // That could be the case for example with a PointScale and a string as domain.\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset\n      };\n    });\n    return result.filter(row => !isNan(row.coordinate));\n  }\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount)\n    // @ts-expect-error why does the offset go here? The type does not require it\n    .map(entry => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nexport var selectTicksOfAxis = createSelector([selectChartLayout, selectAxisSettings, selectRealScaleType, selectAxisScale, selectNiceTicks, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineAxisTicks);\nexport var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {\n  if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) {\n    return undefined;\n  }\n  var isCategorical = isCategoricalAxis(layout, axisType);\n  var {\n    tickCount\n  } = axis;\n  var offset = 0;\n  offset = axisType === 'angleAxis' && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;\n\n  // When axis is a categorical axis, but the type of axis is number or the scale of axis is not \"auto\"\n  if (isCategorical && categoricalDomain) {\n    return categoricalDomain.map((entry, index) => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      index,\n      offset\n    }));\n  }\n  if (scale.ticks) {\n    return scale.ticks(tickCount)\n    // @ts-expect-error why does the offset go here? The type does not require it\n    .map(entry => ({\n      coordinate: scale(entry) + offset,\n      value: entry,\n      offset\n    }));\n  }\n\n  // When axis has duplicated text, serial numbers are used to generate scale\n  return scale.domain().map((entry, index) => ({\n    coordinate: scale(entry) + offset,\n    value: duplicateDomain ? duplicateDomain[entry] : entry,\n    index,\n    offset\n  }));\n};\nexport var selectTicksOfGraphicalItem = createSelector([selectChartLayout, selectAxisSettings, selectAxisScale, selectAxisRange, selectDuplicateDomain, selectCategoricalDomain, pickAxisType], combineGraphicalItemTicks);\nexport var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\nvar selectZAxisScale = createSelector([selectBaseAxis, selectRealScaleType, selectAxisDomain, selectAxisRangeWithReverse], combineScaleFunction);\nexport var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {\n  if (axis == null || scale == null) {\n    return undefined;\n  }\n  return _objectSpread(_objectSpread({}, axis), {}, {\n    scale\n  });\n});\n\n/**\n * We are also going to need to implement polar chart directions if we want to support keyboard controls for those.\n */\n\nexport var selectChartDirection = createSelector([selectChartLayout, selectAllXAxes, selectAllYAxes], (layout, allXAxes, allYAxes) => {\n  switch (layout) {\n    case 'horizontal':\n      {\n        return allXAxes.some(axis => axis.reversed) ? 'right-to-left' : 'left-to-right';\n      }\n    case 'vertical':\n      {\n        return allYAxes.some(axis => axis.reversed) ? 'bottom-to-top' : 'top-to-bottom';\n      }\n    // TODO: make this better. For now, right arrow triggers \"forward\", left arrow \"back\"\n    // however, the tooltip moves an unintuitive direction because of how the indices are rendered\n    case 'centric':\n    case 'radial':\n      {\n        return 'left-to-right';\n      }\n    default:\n      {\n        return undefined;\n      }\n  }\n});"]},"metadata":{},"sourceType":"module"}